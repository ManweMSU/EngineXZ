auxilium attributum ("NomenModuli") = "Liber Canonicalis";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2023";
auxilium attributum ("Versio") = "1.0.0.1";

[[systema] liber]

[[innatum]] [[magnitudo] "0"] [[significatio] nihil]
genus nihil {}

[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus logicum {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (logicum src) {
		INTERFACE W 1 : THIS 1 => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio logicum operator - () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ~ () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~logicum operator = (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator |= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator &= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator #= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio logicum operator | (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator & (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator # (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @SAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTSAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] signum_integer]
genus int8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio int8 operator - () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio int8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~int8 operator = (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator += (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator *= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator /= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator %= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator |= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator &= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator #= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator <<= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator >>= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int8 operator + (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator - (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator * (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator / (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator % (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator | (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator & (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator # (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator << (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator >> (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus nint8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio nint8 operator - () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio nint8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~nint8 operator = (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator += (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator *= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator /= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator %= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator |= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator &= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator #= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator <<= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator >>= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint8 operator + (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator - (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator * (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator / (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator % (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator | (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator & (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator # (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator << (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator >> (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] signum_integer]
genus int16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio int16 operator - () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio int16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~int16 operator = (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator += (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator *= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator /= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator %= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator |= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator &= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator #= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator <<= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator >>= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int16 operator + (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator - (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator * (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator / (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator % (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator | (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator & (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator # (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator << (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator >> (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer]
genus nint16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio nint16 operator - () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio nint16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~nint16 operator = (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator += (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator *= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator /= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator %= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator |= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator &= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator #= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator <<= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator >>= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint16 operator + (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator - (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator * (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator / (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator % (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator | (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator & (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator # (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator << (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator >> (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] signum_integer]
genus int32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio int32 operator - () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio int32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~int32 operator = (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator += (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator *= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator /= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator %= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator |= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator &= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator #= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator <<= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator >>= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int32 operator + (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator - (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator * (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator / (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator % (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator | (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator & (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator # (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator << (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator >> (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer]
genus nint32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio nint32 operator - () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio nint32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~nint32 operator = (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator += (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator *= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator /= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator %= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator |= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator &= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator #= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator <<= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator >>= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint32 operator + (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator - (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator * (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator / (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator % (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator | (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator & (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator # (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator << (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator >> (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] signum_integer]
genus int64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio int64 operator - () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio int64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~int64 operator = (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator += (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator *= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator /= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator %= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator |= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator &= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator #= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator <<= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator >>= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int64 operator + (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator - (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator * (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator / (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator % (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator | (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator & (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator # (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator << (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator >> (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer]
genus nint64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio nint64 operator - () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio nint64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~nint64 operator = (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator += (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator *= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator /= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator %= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator |= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator &= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator #= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator <<= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator >>= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint64 operator + (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator - (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator * (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator / (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator % (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator | (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator & (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator # (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator << (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator >> (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] signum_integer]
genus intadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio intadl operator - () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio intadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~intadl operator = (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator += (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator *= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator /= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator %= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator |= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator &= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator #= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator <<= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator >>= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio intadl operator + (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator - (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator * (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator / (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator % (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator | (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator & (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator # (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator << (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator >> (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer]
genus nintadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio nintadl operator - () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio nintadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~nintadl operator = (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator += (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator *= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator /= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator %= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator |= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator &= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator #= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator <<= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator >>= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nintadl operator + (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator - (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator * (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator / (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator % (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator | (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator & (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator # (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator << (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator >> (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] fractus]
genus frac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[importa] "fpu_32_neg"] [[nullum_thiscall]] functio frac operator - ();
	[[importa] "fpu_32_non"] [[nullum_thiscall]] functio logicum operator ! ();
	[[xa]] functio ~frac operator = (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[importa] "fpu_32_lsm"] [[nullum_thiscall]] functio ~frac operator += (frac src);
	[[importa] "fpu_32_lsb"] [[nullum_thiscall]] functio ~frac operator -= (frac src);
	[[importa] "fpu_32_lml"] [[nullum_thiscall]] functio ~frac operator *= (frac src);
	[[importa] "fpu_32_ldv"] [[nullum_thiscall]] functio ~frac operator /= (frac src);
	[[importa] "fpu_32_inc"] [[nullum_thiscall]] functio ~frac operator ++ ();
	[[importa] "fpu_32_dec"] [[nullum_thiscall]] functio ~frac operator -- ();
	[[importa] "fpu_32_sum"] [[nullum_thiscall]] classis functio frac operator + (frac a, frac b);
	[[importa] "fpu_32_sub"] [[nullum_thiscall]] classis functio frac operator - (frac a, frac b);
	[[importa] "fpu_32_mul"] [[nullum_thiscall]] classis functio frac operator * (frac a, frac b);
	[[importa] "fpu_32_div"] [[nullum_thiscall]] classis functio frac operator / (frac a, frac b);
	[[importa] "fpu_32_par"] [[nullum_thiscall]] classis functio logicum operator == (frac a, frac b);
	[[importa] "fpu_32_npr"] [[nullum_thiscall]] classis functio logicum operator != (frac a, frac b);
	[[importa] "fpu_32_min"] [[nullum_thiscall]] classis functio logicum operator < (frac a, frac b);
	[[importa] "fpu_32_maj"] [[nullum_thiscall]] classis functio logicum operator > (frac a, frac b);
	[[importa] "fpu_32_pmn"] [[nullum_thiscall]] classis functio logicum operator <= (frac a, frac b);
	[[importa] "fpu_32_pmj"] [[nullum_thiscall]] classis functio logicum operator >= (frac a, frac b);
}
[[innatum]] [[magnitudo] "8"] [[significatio] fractus]
genus dfrac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[importa] "fpu_64_neg"] [[nullum_thiscall]] functio dfrac operator - ();
	[[importa] "fpu_64_non"] [[nullum_thiscall]] functio logicum operator ! ();
	[[xa]] functio ~dfrac operator = (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[importa] "fpu_64_lsm"] [[nullum_thiscall]] functio ~dfrac operator += (dfrac src);
	[[importa] "fpu_64_lsb"] [[nullum_thiscall]] functio ~dfrac operator -= (dfrac src);
	[[importa] "fpu_64_lml"] [[nullum_thiscall]] functio ~dfrac operator *= (dfrac src);
	[[importa] "fpu_64_ldv"] [[nullum_thiscall]] functio ~dfrac operator /= (dfrac src);
	[[importa] "fpu_64_inc"] [[nullum_thiscall]] functio ~dfrac operator ++ ();
	[[importa] "fpu_64_dec"] [[nullum_thiscall]] functio ~dfrac operator -- ();
	[[importa] "fpu_64_sum"] [[nullum_thiscall]] classis functio dfrac operator + (dfrac a, dfrac b);
	[[importa] "fpu_64_sub"] [[nullum_thiscall]] classis functio dfrac operator - (dfrac a, dfrac b);
	[[importa] "fpu_64_mul"] [[nullum_thiscall]] classis functio dfrac operator * (dfrac a, dfrac b);
	[[importa] "fpu_64_div"] [[nullum_thiscall]] classis functio dfrac operator / (dfrac a, dfrac b);
	[[importa] "fpu_64_par"] [[nullum_thiscall]] classis functio logicum operator == (dfrac a, dfrac b);
	[[importa] "fpu_64_npr"] [[nullum_thiscall]] classis functio logicum operator != (dfrac a, dfrac b);
	[[importa] "fpu_64_min"] [[nullum_thiscall]] classis functio logicum operator < (dfrac a, dfrac b);
	[[importa] "fpu_64_maj"] [[nullum_thiscall]] classis functio logicum operator > (dfrac a, dfrac b);
	[[importa] "fpu_64_pmn"] [[nullum_thiscall]] classis functio logicum operator <= (dfrac a, dfrac b);
	[[importa] "fpu_64_pmj"] [[nullum_thiscall]] classis functio logicum operator >= (dfrac a, dfrac b);
}

nomen_alternum int = int32;
nomen_alternum nint = nint32;
nomen_alternum frac32 = frac;
nomen_alternum frac64 = dfrac;
nomen_alternum char = nint32;

dura logicum {
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_l_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_l_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_i8_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i8_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_n8_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n8_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[importa] "fpu_i16_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i16_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[importa] "fpu_n16_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n16_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[importa] "fpu_i32_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i32_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[importa] "fpu_n32_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n32_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[importa] "fpu_i64_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i64_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[importa] "fpu_n64_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n64_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura intadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[importa] "fpu_iadl_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_iadl_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nintadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[importa] "fpu_nadl_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_nadl_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura frac {
	[[importa] "fpu_f32_ad_l"]		[[nullum_thiscall]] convertor (logicum) ();
	[[importa] "fpu_f32_ad_i8"]		[[nullum_thiscall]] convertor (int8) ();
	[[importa] "fpu_f32_ad_n8"]		[[nullum_thiscall]] convertor (nint8) ();
	[[importa] "fpu_f32_ad_i16"]	[[nullum_thiscall]] convertor (int16) ();
	[[importa] "fpu_f32_ad_n16"]	[[nullum_thiscall]] convertor (nint16) ();
	[[importa] "fpu_f32_ad_i32"]	[[nullum_thiscall]] convertor (int32) ();
	[[importa] "fpu_f32_ad_n32"]	[[nullum_thiscall]] convertor (nint32) ();
	[[importa] "fpu_f32_ad_i64"]	[[nullum_thiscall]] convertor (int64) ();
	[[importa] "fpu_f32_ad_n64"]	[[nullum_thiscall]] convertor (nint64) ();
	[[importa] "fpu_f32_ad_iadl"]	[[nullum_thiscall]] convertor (intadl) ();
	[[importa] "fpu_f32_ad_nadl"]	[[nullum_thiscall]] convertor (nintadl) ();
	[[importa] "fpu_f32_ad_f64"]	[[nullum_thiscall]] convertor (dfrac) ();
}
dura dfrac {
	[[importa] "fpu_f64_ad_l"]		[[nullum_thiscall]] convertor (logicum) ();
	[[importa] "fpu_f64_ad_i8"]		[[nullum_thiscall]] convertor (int8) ();
	[[importa] "fpu_f64_ad_n8"]		[[nullum_thiscall]] convertor (nint8) ();
	[[importa] "fpu_f64_ad_i16"]	[[nullum_thiscall]] convertor (int16) ();
	[[importa] "fpu_f64_ad_n16"]	[[nullum_thiscall]] convertor (nint16) ();
	[[importa] "fpu_f64_ad_i32"]	[[nullum_thiscall]] convertor (int32) ();
	[[importa] "fpu_f64_ad_n32"]	[[nullum_thiscall]] convertor (nint32) ();
	[[importa] "fpu_f64_ad_i64"]	[[nullum_thiscall]] convertor (int64) ();
	[[importa] "fpu_f64_ad_n64"]	[[nullum_thiscall]] convertor (nint64) ();
	[[importa] "fpu_f64_ad_iadl"]	[[nullum_thiscall]] convertor (intadl) ();
	[[importa] "fpu_f64_ad_nadl"]	[[nullum_thiscall]] convertor (nintadl) ();
	[[importa] "fpu_f64_ad_f32"]	[[nullum_thiscall]] convertor (frac) ();
}

[[xa]] functio logicum operator == (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
}
[[xa]] functio logicum operator != (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
}

spatium math {
	dura .frac {
		constatus pi = frac(3.14159265358979323846);
		constatus e = frac(2.71828182845904523536);
	}
	dura .dfrac {
		constatus pi = 3.14159265358979323846;
		constatus e = 2.71828182845904523536;
	}
	spatium casualis {
		[[importa] fpu_ncg_1]	functio nihil data(@nihil data, int long);
		[[importa] fpu_ncg_2]	functio int integer(int min, int max);
		[[importa] fpu_ncg_3]	functio dfrac fractus();
	}

	[[importa] fpu_f32_pi]	functio frac inf_pos_s();
	[[importa] fpu_f32_ni]	functio frac inf_neg_s();
	[[importa] fpu_f32_nn]	functio frac nn_s();
	[[importa] fpu_f64_pi]	functio dfrac inf_pos_d();
	[[importa] fpu_f64_ni]	functio dfrac inf_neg_d();
	[[importa] fpu_f64_nn]	functio dfrac nn_d();
	[[importa] fpu_ei_32]	functio logicum est_inf(frac valor);
	[[importa] fpu_ei_64]	functio logicum est_inf(dfrac valor);
	[[importa] fpu_enn_32]	functio logicum est_nn(frac valor);
	[[importa] fpu_enn_64]	functio logicum est_nn(dfrac valor);

	[[importa] fpu_abs_i8]	functio int8	abs(int8 valor);
	[[importa] fpu_abs_i16]	functio int16	abs(int16 valor);
	[[importa] fpu_abs_i32]	functio int32	abs(int32 valor);
	[[importa] fpu_abs_i64]	functio int64	abs(int64 valor);
	[[importa] fpu_abs_iad]	functio intadl	abs(intadl valor);
	[[importa] fpu_abs_f32]	functio frac	abs(frac valor);
	[[importa] fpu_abs_f64]	functio dfrac	abs(dfrac valor);

	[[importa] fpu_sgn_i8]	functio int8	sgn(int8 valor);
	[[importa] fpu_sgn_i16]	functio int16	sgn(int16 valor);
	[[importa] fpu_sgn_i32]	functio int32	sgn(int32 valor);
	[[importa] fpu_sgn_i64]	functio int64	sgn(int64 valor);
	[[importa] fpu_sgn_iad]	functio intadl	sgn(intadl valor);
	[[importa] fpu_sgn_f32]	functio frac	sgn(frac valor);
	[[importa] fpu_sgn_f64]	functio dfrac	sgn(dfrac valor);

	[[importa] fpu_c1]		functio frac	concava(frac valor);
	[[importa] fpu_c1_d]	functio dfrac	concava(dfrac valor);
	[[importa] fpu_c2]		functio frac	trunca(frac valor);
	[[importa] fpu_c2_d]	functio dfrac	trunca(dfrac valor);
	[[importa] fpu_c3]		functio frac	solum(frac valor);
	[[importa] fpu_c3_d]	functio dfrac	solum(dfrac valor);
	[[importa] fpu_c4]		functio frac	tectum(frac valor);
	[[importa] fpu_c4_d]	functio dfrac	tectum(dfrac valor);

	[[importa] fpu_rdx]		functio frac	radix(frac valor);
	[[importa] fpu_rdx_d]	functio dfrac	radix(dfrac valor);
	[[importa] fpu_pot]		functio frac	pot(frac valor, frac pot);
	[[importa] fpu_pot_d]	functio dfrac	pot(dfrac valor, dfrac pot);

	[[importa] fpu_exp]		functio frac	exp(frac valor);
	[[importa] fpu_exp_d]	functio dfrac	exp(dfrac valor);
	[[importa] fpu_ln]		functio frac	ln(frac valor);
	[[importa] fpu_ln_d]	functio dfrac	ln(dfrac valor);
	[[importa] fpu_lb]		functio frac	lb(frac valor);
	[[importa] fpu_lb_d]	functio dfrac	lb(dfrac valor);
	[[importa] fpu_lg]		functio frac	lg(frac valor);
	[[importa] fpu_lg_d]	functio dfrac	lg(dfrac valor);

	[[importa] fpu_sin]		functio frac	sin(frac valor);
	[[importa] fpu_sin_d]	functio dfrac	sin(dfrac valor);
	[[importa] fpu_cos]		functio frac	cos(frac valor);
	[[importa] fpu_cos_d]	functio dfrac	cos(dfrac valor);
	[[importa] fpu_tg]		functio frac	tg(frac valor);
	[[importa] fpu_tg_d]	functio dfrac	tg(dfrac valor);
	[[importa] fpu_ctg]		functio frac	ctg(frac valor);
	[[importa] fpu_ctg_d]	functio dfrac	ctg(dfrac valor);

	[[importa] fpu_asin]	functio frac	arcsin(frac valor);
	[[importa] fpu_asin_d]	functio dfrac	arcsin(dfrac valor);
	[[importa] fpu_acos]	functio frac	arccos(frac valor);
	[[importa] fpu_acos_d]	functio dfrac	arccos(dfrac valor);
	[[importa] fpu_atg]		functio frac	arctg(frac valor);
	[[importa] fpu_atg_d]	functio dfrac	arctg(dfrac valor);
	[[importa] fpu_actg]	functio frac	arcctg(frac valor);
	[[importa] fpu_actg_d]	functio dfrac	arcctg(dfrac valor);
}
spatium memoria {
	[[importa] alloca_memoriam]		functio @nihil alloca(nintadl magn);
	[[importa] realloca_memoriam]	functio @nihil realloca(@nihil mem, nintadl magn);
	[[importa] dimitte_memoriam]	functio nihil dimitte(@nihil mem);
	[[importa] relabe_memoriam]		functio nihil relabe(@nihil mem, nintadl magn);
	[[importa] exscribe_memoriam]	functio @nihil exscribe(@nihil in, @nihil ex, nintadl magn);
}
spatium errores {
	[error] constatus error_nullus		= 0x00;
	[error] constatus implantatio_nulla	= 0x01;
	[error] constatus memoria_nulla		= 0x02;
	[error] constatus argumentum_falsum	= 0x03;
	[error] constatus efformatio_falsa	= 0x04;
	[error] constatus habitus_falsus	= 0x05;
	[error] constatus ie_falsum			= 0x06;
	[error] constatus xe_defectus		= 0x07;

	[sub_error ie_falsum] constatus ie_error_nullus					= 0x00;
	[sub_error ie_falsum] constatus ie_error_ignotus				= 0x01;
	[sub_error ie_falsum] constatus ie_lima_nulla					= 0x02;
	[sub_error ie_falsum] constatus ie_semita_nulla					= 0x03;
	[sub_error ie_falsum] constatus ie_nimium_limae_apertae			= 0x04;
	[sub_error ie_falsum] constatus ie_permissio_nulla				= 0x05;
	[sub_error ie_falsum] constatus ie_manubrium_defectum			= 0x06;
	[sub_error ie_falsum] constatus ie_memoria_nulla				= 0x07;
	[sub_error ie_falsum] constatus ie_machinatio_defecta			= 0x08;
	[sub_error ie_falsum] constatus ie_sole_legere					= 0x09;
	[sub_error ie_falsum] constatus ie_spatium_disci_nullum			= 0x0A;
	[sub_error ie_falsum] constatus ie_lima_preexistat				= 0x0B;
	[sub_error ie_falsum] constatus ie_implantatio_nulla			= 0x0C;
	[sub_error ie_falsum] constatus ie_collectorium_non_vacuum		= 0x0D;
	[sub_error ie_falsum] constatus ie_collectorium_est_currens		= 0x0E;
	[sub_error ie_falsum] constatus ie_machinatio_non_idem			= 0x0F;
	[sub_error ie_falsum] constatus ie_nomen_semitae_defectum		= 0x10;
	[sub_error ie_falsum] constatus ie_nomen_limae_nimium_largum	= 0x11;
	[sub_error ie_falsum] constatus ie_lima_nimium_larga			= 0x12;
	[sub_error ie_falsum] constatus ie_legere_falsum				= 0x13;
	[sub_error ie_falsum] constatus ie_scribere_falsum				= 0x14;
	[sub_error ie_falsum] constatus ie_creare_falsum				= 0x15;
	[sub_error ie_falsum] constatus ie_aperire_falsum				= 0x16;

	[sub_error xe_defectus] constatus xe_error_nullus			= 0x00;
	[sub_error xe_defectus] constatus xe_modulus_nullus			= 0x01;
	[sub_error xe_defectus] constatus xe_imago_falsa			= 0x02;
	[sub_error xe_defectus] constatus xe_functio_falsa			= 0x03;
	[sub_error xe_defectus] constatus xe_abi_functionis_falsa	= 0x04;
	[sub_error xe_defectus] constatus xe_symbolus_duplicatus	= 0x05;
	[sub_error xe_defectus] constatus xe_adhaesio_defecta		= 0x06;
	[sub_error xe_defectus] constatus xe_importus_falsus		= 0x07;
	[sub_error xe_defectus] constatus xe_librarium_nullum		= 0x08;
	[sub_error xe_defectus] constatus xe_lib_importus_falsus	= 0x09;
	[sub_error xe_defectus] constatus xe_allocatus_defectus		= 0x0A;
	[sub_error xe_defectus] constatus xe_initium_defectum		= 0x0B;
}

[[importa] inc_sec] functio nint incrementum_securum(~nint valor);
[[importa] dec_sec] functio nint decrementum_securum(~nint valor);

genus linea {
	@nihil _data;
	int longitudo { [[importa] "spu_long"] [[nullum_thiscall]] adipisce; }

	functio int initus() { responde 0; }
	functio int finis() { responde longitudo - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde longitudo; }

	constatus radix_bina		= "01";
	constatus radix_octava		= "01234567";
	constatus radix_decima		= "0123456789";
	constatus radix_sextadecima	= "0123456789ABCDEF";

	structor () { _data = nullus; }
	structor motus (~linea s) { _data = s._data; s._data = nullus; }
	destructor () { memoria.dimitte(_data); }

	[[importa] "spu_crea"]			[[nullum_thiscall]] structor (~linea valor) iacit;
	[[importa] "spu_crea_utf32"]	[[nullum_thiscall]] structor (@char valor) iacit;

	enumeratio codex {
		ignotus		= 0x00,
		ascii		= 0x01,
		utf8		= 0x02,
		utf16		= 0x03,
		utf32		= 0x04,
	}

	[[importa] "spu_crea_int8"]		[[nullum_thiscall]] structor (int8 valor) iacit;
	[[importa] "spu_crea_nint8"]	[[nullum_thiscall]] structor (nint8 valor) iacit;
	[[importa] "spu_crea_int16"]	[[nullum_thiscall]] structor (int16 valor) iacit;
	[[importa] "spu_crea_nint16"]	[[nullum_thiscall]] structor (nint16 valor) iacit;
	[[importa] "spu_crea_int32"]	[[nullum_thiscall]] structor (int32 valor) iacit;
	[[importa] "spu_crea_nint32"]	[[nullum_thiscall]] structor (nint32 valor) iacit;
	[[importa] "spu_crea_int64"]	[[nullum_thiscall]] structor (int64 valor) iacit;
	[[importa] "spu_crea_nint64"]	[[nullum_thiscall]] structor (nint64 valor) iacit;
	[[importa] "spu_crea_intadl"]	[[nullum_thiscall]] structor (intadl valor) iacit;
	[[importa] "spu_crea_nintadl"]	[[nullum_thiscall]] structor (nintadl valor) iacit;
	[[importa] "spu_crea_frac32"]	[[nullum_thiscall]] structor (frac valor) iacit;
	[[importa] "spu_crea_frac64"]	[[nullum_thiscall]] structor (dfrac valor) iacit;
	[[importa] "spu_crea_logicum"]	[[nullum_thiscall]] structor (logicum valor) iacit;
	[[importa] "spu_crea_char"]		[[nullum_thiscall]] structor (char valor, int long) iacit;
	[[importa] "spu_crea_adl"]		[[nullum_thiscall]] structor (@nihil valor) iacit;
	[[importa] "spu_crea_data"]		[[nullum_thiscall]] structor (@nihil valor, int long, codex cdx) iacit;
	[[importa] "spu_loca"]			[[nullum_thiscall]] functio ~linea operator = (~linea valor) iacit;
	[[importa] "spu_loca_utf32"]	[[nullum_thiscall]] functio ~linea operator = (@char valor) iacit;
	[[importa] "spu_concat"]		[[nullum_thiscall]] functio ~linea operator += (~linea valor) iacit;
	[[importa] "spu_index"]			[[nullum_thiscall]] functio char operator [] (int index);

	[[importa] "spu_crea_nint32_radix"]		[[nullum_thiscall]] structor (nint32 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nint64_radix"]		[[nullum_thiscall]] structor (nint64 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nintadl_radix"]	[[nullum_thiscall]] structor (nintadl valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_frac32_2"]			[[nullum_thiscall]] structor (frac valor, char punctum) iacit;
	[[importa] "spu_crea_frac32_3"]			[[nullum_thiscall]] structor (frac valor, char punctum, int long) iacit;
	[[importa] "spu_crea_frac64_2"]			[[nullum_thiscall]] structor (dfrac valor, char punctum) iacit;
	[[importa] "spu_crea_frac64_3"]			[[nullum_thiscall]] structor (dfrac valor, char punctum, int long) iacit;

	[[importa] "spu_concat_classis"]	classis functio linea operator + (~linea a, ~linea b) iacit;
	[[importa] "spu_compareo"]			classis functio int operator <=> (~linea a, ~linea b);
	[[importa] "spu_compareo_2"]		classis functio int operator # (~linea a, ~linea b);

	classis functio logicum operator == (~linea a, ~linea b) iacit { responde a <=> b == 0; }
	classis functio logicum operator != (~linea a, ~linea b) iacit { responde a <=> b != 0; }
	classis functio logicum operator <= (~linea a, ~linea b) iacit { responde a <=> b <= 0; }
	classis functio logicum operator >= (~linea a, ~linea b) iacit { responde a <=> b >= 0; }
	classis functio logicum operator < (~linea a, ~linea b) iacit { responde a <=> b < 0; }
	classis functio logicum operator > (~linea a, ~linea b) iacit { responde a <=> b > 0; }

	[[importa] "spu_reperi_primus"]		[[nullum_thiscall]] functio int reperi_primus(~linea valor);
	[[importa] "spu_reperi_ultimus"]	[[nullum_thiscall]] functio int reperi_ultimus(~linea valor);
	[[importa] "spu_fragmentum"]		[[nullum_thiscall]] functio linea fragmentum(int primus, int long) iacit;
	[[importa] "spu_surroga"]			[[nullum_thiscall]] functio linea surroga(~linea sublinea, ~linea cum) iacit;
	[[importa] "spu_codex_long"]		[[nullum_thiscall]] functio int longitudo_codicis(codex cdx) iacit;
	[[importa] "spu_codifica"]			[[nullum_thiscall]] functio nihil codifica(@nihil data, codex cdx, logicum termina) iacit;
	
	[[importa] "spu_ad_int32"]			[[nullum_thiscall]] functio int32 ad_int32() iacit;
	[[importa] "spu_ad_int32_2"]		[[nullum_thiscall]] functio int32 ad_int32(~linea radix) iacit;
	[[importa] "spu_ad_int32_3"]		[[nullum_thiscall]] functio int32 ad_int32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint32"]			[[nullum_thiscall]] functio nint32 ad_nint32() iacit;
	[[importa] "spu_ad_nint32_2"]		[[nullum_thiscall]] functio nint32 ad_nint32(~linea radix) iacit;
	[[importa] "spu_ad_nint32_3"]		[[nullum_thiscall]] functio nint32 ad_nint32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_int64"]			[[nullum_thiscall]] functio int64 ad_int64() iacit;
	[[importa] "spu_ad_int64_2"]		[[nullum_thiscall]] functio int64 ad_int64(~linea radix) iacit;
	[[importa] "spu_ad_int64_3"]		[[nullum_thiscall]] functio int64 ad_int64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint64"]			[[nullum_thiscall]] functio nint64 ad_nint64() iacit;
	[[importa] "spu_ad_nint64_2"]		[[nullum_thiscall]] functio nint64 ad_nint64(~linea radix) iacit;
	[[importa] "spu_ad_nint64_3"]		[[nullum_thiscall]] functio nint64 ad_nint64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_frac32"]			[[nullum_thiscall]] functio frac ad_frac() iacit;
	[[importa] "spu_ad_frac32_2"]		[[nullum_thiscall]] functio frac ad_frac(~linea punctum) iacit;
	[[importa] "spu_ad_frac64"]			[[nullum_thiscall]] functio dfrac ad_dfrac() iacit;
	[[importa] "spu_ad_frac64_2"]		[[nullum_thiscall]] functio dfrac ad_dfrac(~linea punctum) iacit;

	[[importa] "spu_forma_0"] classis functio linea forma(~linea schema, ~linea a0) iacit;
	[[importa] "spu_forma_1"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1) iacit;
	[[importa] "spu_forma_2"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2) iacit;
	[[importa] "spu_forma_3"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3) iacit;
	[[importa] "spu_forma_4"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4) iacit;
	[[importa] "spu_forma_5"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5) iacit;
	[[importa] "spu_forma_6"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6) iacit;
	[[importa] "spu_forma_7"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7) iacit;
	[[importa] "spu_forma_8"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8) iacit;
	[[importa] "spu_forma_9"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8, ~linea a9) iacit;

	linea inferna	{ [[importa] "spu_inferna"]	[[nullum_thiscall]] adipisce iacit; }
	linea supera	{ [[importa] "spu_supera"]	[[nullum_thiscall]] adipisce iacit; }
}
genus linea_secura hereditat linea {
	structor () {}
	structor (~linea_secura valor) { _data = valor._data; valor._data = nullus; }
	[[nullum_thiscall]] [[importa] spu_crea_sec] structor (~linea valor);
}

spatium errores {
	[[importa] descriptio_erroris] functio nihil _descriptio_erroris(nintadl ec, nintadl esc, @nihil mdl, ~linea error, ~linea sub_error);
	functio nihil descriptio(nintadl ec, nintadl esc, ~linea error, ~linea sub_error) { _descriptio_erroris(ec, esc, modulus(), error, sub_error); }
}
spatium actuarius {
	protocollum _actuarius { functio nihil scribe(~linea ln) virtualis pura; }
	functio nihil scribe(~linea ln) { (@_actuarius)(protocollum(actuarius))^.scribe(ln); }
}
spatium systema {
	constatus architectura_ignota	= 0x00;
	constatus architectura_i386		= 0x01;
	constatus architectura_x64		= 0x11;
	constatus architectura_arm_m32	= 0x02;
	constatus architectura_arm_a64	= 0x12;

	constatus systema_ignota	= 0x00;
	constatus systema_windows	= 0x01;
	constatus systema_macos		= 0x02;
	constatus systema_linux		= 0x03;

	structura informatio {
		int64 frequentia_processoris;
		int64 numerus_memoriae;
		linea nomen_processoris;
		int32 systema_machinae;
		int32 architectura_machinae;
		int32 architectura_processi;
		int32 numerus_corda_corporalia;
		int32 numerus_corda_virtualia;
		int32 versio_systemae_supera;
		int32 versio_systemae_inferna;
	}

	[[importa] sys_info]	functio nihil para_informatio(~informatio inf);
	[[importa] sys_temp]	functio nint32 para_tempus_systemae();
	[[importa] sys_arch]	functio logicum proba_architecturam(int arch);
}
enumeratio tactus {
	back		= 0x08,
	tab			= 0x09,
	enter		= 0x0D,
	shift		= 0x10,
	ctrl		= 0x11,
	alt			= 0x12,
	system		= 0xFFFF,
	pause		= 0x13,
	caps_lock	= 0x14,
	escape		= 0x1B,
	l_shift		= 0xA0,
	r_shift		= 0xA1,
	l_ctrl		= 0xA2,
	r_ctrl		= 0xA3,
	l_alt		= 0xA4,
	r_alt		= 0xA5,
	l_system	= 0x5B,
	r_system	= 0x5C,
	space		= ' ',
	page_up		= 0x21,
	page_down	= 0x22,
	end			= 0x23,
	home		= 0x24,
	left		= 0x25,
	up			= 0x26,
	right		= 0x27,
	down		= 0x28,
	select		= 0x29,
	print		= 0x2A,
	execute		= 0x2B,
	prnt_scrn	= 0x2C,
	insert		= 0x2D,
	delete		= 0x2E,
	help		= 0x2F,
	N0			= '0',
	N1			= '1',
	N2			= '2',
	N3			= '3',
	N4			= '4',
	N5			= '5',
	N6			= '6',
	N7			= '7',
	N8			= '8',
	N9			= '9',
	A			= 'A',
	B			= 'B',
	C			= 'C',
	D			= 'D',
	E			= 'E',
	F			= 'F',
	G			= 'G',
	H			= 'H',
	I			= 'I',
	J			= 'J',
	K			= 'K',
	L			= 'L',
	M			= 'M',
	N			= 'N',
	O			= 'O',
	P			= 'P',
	Q			= 'Q',
	R			= 'R',
	S			= 'S',
	T			= 'T',
	U			= 'U',
	V			= 'V',
	W			= 'W',
	X			= 'X',
	Y			= 'Y',
	Z			= 'Z',
	sleep		= 0x5F,
	NP0			= 0x60,
	NP1			= 0x61,
	NP2			= 0x62,
	NP3			= 0x63,
	NP4			= 0x64,
	NP5			= 0x65,
	NP6			= 0x66,
	NP7			= 0x67,
	NP8			= 0x68,
	NP9			= 0x69,
	multiply	= 0x6A,
	add			= 0x6B,
	separator	= 0x6C,
	subtract	= 0x6D,
	decimal		= 0x6E,
	divide		= 0x6F,
	F1			= 0x70,
	F2			= 0x71,
	F3			= 0x72,
	F4			= 0x73,
	F5			= 0x74,
	F6			= 0x75,
	F7			= 0x76,
	F8			= 0x77,
	F9			= 0x78,
	F10			= 0x79,
	F11			= 0x7A,
	F12			= 0x7B,
	F13			= 0x7C,
	F14			= 0x7D,
	F15			= 0x7E,
	F16			= 0x7F,
	F17			= 0x80,
	F18			= 0x81,
	F19			= 0x82,
	F20			= 0x83,
	F21			= 0x84,
	F22			= 0x85,
	F23			= 0x86,
	F24			= 0x87,
	num_lock	= 0x90,
	scrl_lock	= 0x91,
	oem_plus	= 0xBB,
	oem_comma	= 0xBC,
	oem_minus	= 0xBD,
	oem_prd		= 0xBE,
	oem_clear	= 0xFE,
	vol_mute	= 0xAD,
	vol_down	= 0xAE,
	vol_up		= 0xAF,
	OEM1		= 0xBA,
	OEM2		= 0xBF,
	OEM3		= 0xC0,
	OEM4		= 0xDB,
	OEM5		= 0xDC,
	OEM6		= 0xDD,
	OEM7		= 0xDE,
	OEM8		= 0xFF,
}

[[magnitudo] "0:2"] genus virtualis objectum {
	[[positus] "0:1"] nint _num_ref;

	structor () { funda _num_ref(1); }
	functio nint contine() virtualis { responde incrementum_securum(_num_ref); }
	functio nint dimitte() virtualis { var nr = decrementum_securum(_num_ref); si (nr == nint(0)) perde ego; responde nr; }
	destructor () virtualis {}
	functio nihil _perde() virtualis { perde ego; }
	functio linea_secura ad_linea() virtualis { proba { responde linea("objectum"); } responde linea_secura(); }
}

praeforma functio permuta(T) { \cense T genus(_0)\ functio nihil $_(~$T t1, ~$T t2) {
	ordo [magnitudo_maxima($T)] nint8 m;
	memoria.exscribe(@m, @t1, magnitudo(t1));
	memoria.exscribe(@t1, @t2, magnitudo(t1));
	memoria.exscribe(@t2, @m, magnitudo(t1));
} }
praeforma genus dordo(V) { genus $_ hereditat objectum {
	@$V _data;
	int _numerus;
	int _allocatus;
	int _talea;

	functio int _poli(int num) { responde ((num + _talea - 1) / _talea) * _talea; }
	functio nihil _adde(~$V v) iacit { initia(@_data[_numerus], v); _numerus++; }
	functio nihil _realloca(int num) iacit
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _allocatus) {
			si (numerus_novus > _allocatus) {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; } alioqui iace errores.memoria_nulla;
			} alioqui {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
			}
		}
	}
	functio nihil _realloca_secura(int num)
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _numerus) {
			var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
			si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
		}
	}

	structor () { funda _numerus(0); funda _allocatus(0); funda _talea(0x100); _data = nullus; }
	structor (~dordo[$V] valor) iacit
	{
		funda _numerus(valor._numerus);
		funda _allocatus(0);
		funda _talea(valor._talea);
		_data = nullus;
		_realloca(_numerus);
		int i = 0;
		proba { pro (i = 0; i < _numerus; i++) initia(@_data[i], valor._data[i]); } cape (intadl e, intadl se) {
			pro (int j = i - 1; j >= 0; j--) fini(_data[i]);
			memoria.dimitte(_data);
			iace e, se;
		}
	}
	structor (int talea) { funda _numerus(0); funda _allocatus(0); funda _talea(talea); _data = nullus; }
	destructor() redefini { pro (int i = 0; i < _numerus; i++) fini(_data[i]); memoria.dimitte(_data); }

	functio ~dordo[$V] operator = (~dordo[$V] valor) iacit
	{
		si (ego == @valor) responde ego^;
		dordo[$V] copia(valor);
		pro (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = copia._data;
		_numerus = copia._numerus;
		_allocatus = copia._allocatus;
		_talea = copia._talea;
		copia._data = nullus;
		copia._numerus = copia._allocatus = 0;
		responde ego^;
	}
	functio ~$V operator [] (int i) { responde _data[i]; }
	convertor (@$V) () { responde _data; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~$V v) iacit { o.adde(v); responde o; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~dordo[$V] o2) iacit { o.adde(o2); responde o; }

	functio nihil adde(~$V v) iacit { _realloca(_numerus + 1); _adde(v); }
	functio nihil adde(~dordo[$V] o) iacit
	{
		si (ego == @o) iace errores.argumentum_falsum;
		_realloca(_numerus + o._numerus);
		pro (int i = 0; i < o._numerus; i++) _adde(o._data[i]);
	}
	functio nihil adde(@$V v, int numerus) iacit
	{
		si (!numerus) responde;
		si (v == _data) iace errores.argumentum_falsum;
		_realloca(_numerus + numerus);
		pro (int i = 0; i < numerus; i++) _adde(v[i]);
	}
	functio nihil permuta(int i, int j) { .permuta(_data[i], _data[j]); }
	functio nihil insere(~$V v, int pos) iacit
	{
		_realloca(_numerus + 1);
		pro (int i = _numerus - 1; i >= pos; i--) .permuta(_data[i], _data[i + 1]);
		proba { initia(@_data[pos], v); _numerus++; }
		cape (intadl e, intadl se) { pro (int i = pos; i < _numerus; i++) .permuta(_data[i], _data[i + 1]); iace e, se; }
	}
	functio nihil remove(int pos)
	{
		fini _data[pos];
		pro (int i = pos; i < _numerus - 1; i++) .permuta(_data[i], _data[i + 1]);
		_numerus--; _realloca_secura(_numerus);
	}
	functio nihil remove_primus() { remove(0); }
	functio nihil remove_ultimus() { remove(_numerus - 1); }
	functio nihil depura()
	{
		pro (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = nullus;
		_numerus = _allocatus = 0;
	}
	functio ~$V primus() { responde _data[0]; }
	functio ~$V ultimus() { responde _data[_numerus - 1]; }

	functio linea_secura ad_linea() redefini
	{
		proba {
			linea resp = "ordo : [";
			pro (int i = 0; i < _numerus; i++) {
				si (i) resp += ", ";
				resp += linea.ex(_data[i]);
			}
			responde resp + "]";
		}
		responde linea_secura();
	}

	int longitudo {
		adipisce { responde _numerus; }
		\si tractus.habet_structor($V)\ loca iacit {
			si (valor > _numerus) {
				_realloca(valor); int i;
				proba { pro (i = _numerus; i < valor; i++) initia(@_data[i]); }
				cape (intadl e, intadl se) { pro (int j = i - 1; j >= _numerus; j--) fini _data[j]; iace e, se; }
				_numerus = valor;
			} alioqui si (valor < _numerus) {
				si (valor < 0) iace errores.argumentum_falsum;
				pro (int i = valor; i < _numerus; i++) fini _data[i];
				_numerus = valor; _realloca_secura(valor);
			}
		} \fini\
	}
	@$V data { adipisce { responde _data; } }

	functio int initus() { responde 0; }
	functio int finis() { responde _numerus - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde _numerus; }
} }
praeforma genus adl(O) { genus $_ {
	@$O _adl;
	structor () { _adl = nullus; }
	structor (@$O o) { _adl = o; }
	structor (~adl[$O] o) { _adl = o._adl; si(_adl != nullus) _adl^.contine(); }
	destructor () { si(_adl != nullus) _adl^.dimitte(); }
	functio ~$O operator ^ () { responde _adl^; }
	functio logicum operator ! () { responde _adl == nullus; }
	functio ~adl[$O] operator = (~adl[$O] valor)
	{
		si (ego == @valor) responde ego^;
		si (_adl != nullus) _adl^.dimitte();
		_adl = valor._adl;
		si (_adl != nullus) _adl^.contine();
		responde ego^;
	}
	convertor (@$O) () { responde _adl; }
	convertor (logicum) () { responde _adl != nullus; }
	functio @$O valor() { responde _adl; }
	functio @@$O valor_adl() { responde @_adl; }
	functio nihil depura() { si (_adl != nullus) _adl^.dimitte(); _adl = nullus; }
	functio nihil contine(@$O o) { si (_adl != nullus) _adl^.dimitte(); _adl = o; si (_adl != nullus) _adl^.contine(); }
	functio linea_secura ad_linea()
	{
		proba {
			si (_adl == nullus) responde linea("nullus");
			alioqui responde _adl^.ad_linea();
		}
		responde linea_secura();
	}
	classis functio logicum operator == (~adl[$O] a, ~adl[$O] b) { responde a._adl == b._adl; }
	classis functio logicum operator != (~adl[$O] a, ~adl[$O] b) { responde a._adl != b._adl; }
	classis functio logicum operator == (~adl[$O] a, @$O b) { responde a._adl == b; }
	classis functio logicum operator != (~adl[$O] a, @$O b) { responde a._adl != b; }
	classis functio logicum operator == (@$O a, ~adl[$O] b) { responde a == b._adl; }
	classis functio logicum operator != (@$O a, ~adl[$O] b) { responde a != b._adl; }
} }

nomen_alternum dordo_linearum = dordo[linea];
nomen_alternum dordo_datorum = dordo[nint8];

dura linea {
	[[importa] "spu_codifica_taleam"]	[[nullum_thiscall]] functio adl[dordo_datorum] codifica(codex cdx, logicum termina) iacit;
	[[importa] "spu_scinde"]			[[nullum_thiscall]] functio adl[dordo_linearum] scinde(char) iacit;

	praeforma functio ex(T) { \cense T genus(_0)\ functio linea $_(~$T t) iacit {
		\si tractus.convertitur($T, linea)\
			responde linea(t);
		\fini\
		\si !tractus.convertitur($T, linea)\
			\si tractus.habet($T, "ad_linea")\
				\si tractus.habet_vers($T.ad_linea)\
					responde t.ad_linea();
				\fini\
				\si !tractus.habet_vers($T.ad_linea)\
					responde "?";
				\fini\
			\fini\
			\si !tractus.habet($T, "ad_linea")\
				\si tractus.est_cls($T)\
					linea r = "structura " + tractus.nomen($T) + " : [\n";
					\replica F $T\
						r += linea(tractus.nomen($T.\loca F\)) + " = " + linea.ex(t.\loca F\) + "\n";
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_ordo($T)\
					linea r = "ordo : [";
					\replica N $T\
						si (\loca N\) r += ", ";
						r += linea.ex(t[\loca N\]);
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_adl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_fadl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_com($T)\
					responde linea((@nihil)(@t));
				\fini\
				responde "?";
			\fini\
		\fini\
	} }
}

[[significatio] integer] genus tempus {
	nint64 momentum;

	structor () {}
	structor (tempus valor) { funda momentum(valor.momentum); }
	structor (nint64 valor) { funda momentum(valor); }
	[[nullum_thiscall]] [[importa] tmp_crea_7] structor (int annus, int mensis, int dies, int hora, int minuta, int secunda, int millisecunda);
	[[nullum_thiscall]] [[importa] tmp_crea_4] structor (int hora, int minuta, int secunda, int millisecunda);

	classis functio logicum operator == (tempus a, tempus b) { responde a.momentum == b.momentum; }
	classis functio logicum operator != (tempus a, tempus b) { responde a.momentum != b.momentum; }
	classis functio logicum operator <= (tempus a, tempus b) { responde a.momentum <= b.momentum; }
	classis functio logicum operator >= (tempus a, tempus b) { responde a.momentum >= b.momentum; }
	classis functio logicum operator < (tempus a, tempus b) { responde a.momentum < b.momentum; }
	classis functio logicum operator > (tempus a, tempus b) { responde a.momentum > b.momentum; }

	classis functio tempus operator + (tempus a, tempus b) { responde a.momentum + b.momentum; }
	classis functio tempus operator - (tempus a, tempus b) { responde a.momentum - b.momentum; }

	convertor (nint64) () { responde momentum; }
	functio ~tempus operator = (tempus t) { momentum = t.momentum; responde ego^; }
	functio ~tempus operator += (tempus t) { momentum += t.momentum; responde ego^; }
	functio ~tempus operator -= (tempus t) { momentum -= t.momentum; responde ego^; }

	int annus { [[nullum_thiscall]] [[importa] tmp_a_ans] adipisce; }
	int mensis { [[nullum_thiscall]] [[importa] tmp_a_mns] adipisce; }
	int dies_septimanae { [[nullum_thiscall]] [[importa] tmp_a_dis] adipisce; }
	int dies { [[nullum_thiscall]] [[importa] tmp_a_die] adipisce; }
	int hora { [[nullum_thiscall]] [[importa] tmp_a_hor] adipisce; }
	int minuta { [[nullum_thiscall]] [[importa] tmp_a_min] adipisce; }
	int secunda { [[nullum_thiscall]] [[importa] tmp_a_sec] adipisce; }
	int millisecunda { [[nullum_thiscall]] [[importa] tmp_a_msc] adipisce; }

	tempus tempus_universalus { [[nullum_thiscall]] [[importa] tmp_a_uni] adipisce; }
	tempus tempus_localis { [[nullum_thiscall]] [[importa] tmp_a_loc] adipisce; }

	[[nullum_thiscall]] [[importa] tmp_adl] functio linea ad_linea() iacit;
	[[nullum_thiscall]] [[importa] tmp_alb] functio linea ad_linea_brevi() iacit;

	[[nullum_thiscall]] [[importa] tmp_cur] classis functio tempus currens();
	[[nullum_thiscall]] [[importa] tmp_dim] functio int dies_in_mense();
}

genus flumen hereditat objectum {
	constatus initus	= 0;
	constatus currens	= 1;
	constatus finis		= 2;

	structor () {}
	functio int lege(@nihil data, int long) iacit virtualis pura;
	functio nihil scribe(@nihil data, int long) iacit virtualis pura;
	functio int64 quaerita(int64 pos, int origo) iacit virtualis pura;
	int64 longitudo {
		adipisce iacit virtualis pura;
		loca iacit virtualis pura;
	}
	functio nihil annoda() virtualis pura;
	functio logicum _est_xv() virtualis { responde sic; }

	[[nullum_thiscall]] [[importa] flumen_ex_2] functio nihil exscribe(@flumen ad, int64 long) iacit;
	[[nullum_thiscall]] [[importa] flumen_ex_1] functio nihil exscribe(@flumen ad) iacit;
	[[nullum_thiscall]] [[importa] flumen_lo_1] functio adl[dordo_datorum] lege_ordinem(int long) iacit;
	[[nullum_thiscall]] [[importa] flumen_lo_0] functio adl[dordo_datorum] lege_ordinem() iacit;
	[[nullum_thiscall]] [[importa] flumen_so_1] functio nihil scribe_ordinem(@dordo_datorum ord) iacit;
}

[[importa] flumen_mem_0] functio adl[flumen] crea_flumen_in_memoriae() iacit;
[[importa] flumen_mem_2] functio adl[flumen] crea_flumen_in_memoriae(@nihil data, intadl long) iacit;
[[importa] flumen_auxil] functio adl[flumen] para_auxilium(@nihil mod, ~linea aux_genus, int aux_num) iacit;

spatium scriptio {
	constatus finis_char = 0xFFFFFFFF;
	genus codificator hereditat objectum {
		structor () {}
		functio nihil scribe(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam() iacit virtualis pura;
		functio nihil scribe_subscriptionem() iacit virtualis pura;

		classis functio ~codificator operator << (~codificator cdf, ~linea ln) iacit { cdf.scribe(ln); responde cdf; }
	}
	genus decodificator hereditat objectum {
		structor () {}
		functio char lege_characterem() iacit virtualis pura;
		functio linea lege_lineam() iacit virtualis pura;
		functio linea lege_cunctos() iacit virtualis pura;

		logicum finis { adipisce virtualis pura; }
		linea.codex codex { adipisce virtualis pura; }

		classis functio ~decodificator operator >> (~decodificator cdf, ~linea ln) iacit { ln = cdf.lege_lineam(); responde cdf; }
	}

	[[importa] scr_cod_1] functio adl[codificator] codifica(@flumen fl) iacit;
	[[importa] scr_cod_2] functio adl[codificator] codifica(@flumen fl, linea.codex codex) iacit;
	[[importa] scr_dec_1] functio adl[decodificator] decodifica(@flumen fl) iacit;
	[[importa] scr_dec_2] functio adl[decodificator] decodifica(@flumen fl, linea.codex codex) iacit;
}
spatium contextus {
	genus semaphorum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil aperi() virtualis pura;
	}
	genus signale hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil erige() virtualis pura;
		functio nihil inclina() virtualis pura;
	}
	genus labos hereditat objectum {
		structor () {}
		functio nihil exeque(@objectum ctx) virtualis pura;
	}
	genus labos_opperitus hereditat labos {
		structor () {}
		functio adl[signale] para_signale() virtualis pura;
	}
	genus filum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		logicum activum { adipisce virtualis pura; }
		int numerus_exitus { adipisce virtualis pura; }
	}
	genus cauda hereditat objectum {
		structor () {}
		functio logicum adde(@labos lab) virtualis pura;
		functio logicum adde(@@labos lab, int num) virtualis pura;
	}
	genus cauda_simplex hereditat cauda {
		structor () {}
		functio nihil exeque() virtualis pura;
		functio logicum exeque_semel() virtualis pura;
		functio adl[filum] exeque_in_fili() virtualis pura;
		functio nihil siste() virtualis pura;
		functio nihil linque() virtualis pura;
		int longitudo { adipisce virtualis pura; }
	}
	genus cauda_filorum hereditat cauda {
		structor () {}
		functio nihil para_statum(~int num_fil, ~int num_act_fil, ~int num_lab) virtualis pura;
		functio nihil opperire() virtualis pura;
	}

	[[importa] ctx_dormi] functio nihil dormi(nint ms);
	[[importa] ctx_siste] functio nihil siste(nint valor);

	[[importa] ctx_ccsim] functio adl[cauda_simplex] crea_caudam_simplex();
	[[importa] ctx_ccfl0] functio adl[cauda_filorum] crea_caudam_filorum();
	[[importa] ctx_ccfl1] functio adl[cauda_filorum] crea_caudam_filorum(int num);
	[[importa] ctx_crsem] functio adl[semaphorum] crea_semaphorum(int valor);
	[[importa] ctx_crsgn] functio adl[signale] crea_signale();
	[[importa] ctx_crfil] functio adl[filum] exeque(@labos lab);
}