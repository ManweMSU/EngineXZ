auxilium attributum ("NomenModuli") = "Liber Canonicalis";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2023";
auxilium attributum ("Versio") = "1.0.0.1";

[[systema] liber]

[[innatum]] [[magnitudo] "0"] [[significatio] nihil]
genus nihil {}

[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus logicum {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (logicum src) {
		INTERFACE W 1 : THIS 1 => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio logicum operator - () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ~ () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~logicum operator = (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator |= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator &= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator #= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio logicum operator | (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator & (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator # (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @SAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTSAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] signum_integer]
genus int8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio int8 operator - () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio int8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~int8 operator = (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator += (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator *= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator /= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator %= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator |= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator &= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator #= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator <<= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator >>= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int8 operator + (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator - (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator * (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator / (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator % (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator | (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator & (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator # (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator << (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator >> (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus nint8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio nint8 operator - () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio nint8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~nint8 operator = (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator += (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator *= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator /= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator %= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator |= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator &= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator #= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator <<= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator >>= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint8 operator + (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator - (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator * (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator / (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator % (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator | (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator & (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator # (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator << (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator >> (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] signum_integer]
genus int16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio int16 operator - () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio int16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~int16 operator = (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator += (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator *= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator /= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator %= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator |= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator &= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator #= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator <<= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator >>= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int16 operator + (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator - (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator * (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator / (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator % (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator | (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator & (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator # (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator << (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator >> (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer]
genus nint16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio nint16 operator - () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio nint16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~nint16 operator = (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator += (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator *= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator /= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator %= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator |= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator &= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator #= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator <<= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator >>= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint16 operator + (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator - (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator * (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator / (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator % (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator | (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator & (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator # (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator << (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator >> (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] signum_integer]
genus int32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio int32 operator - () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio int32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~int32 operator = (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator += (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator *= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator /= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator %= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator |= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator &= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator #= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator <<= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator >>= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int32 operator + (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator - (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator * (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator / (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator % (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator | (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator & (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator # (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator << (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator >> (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer]
genus nint32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio nint32 operator - () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio nint32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~nint32 operator = (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator += (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator *= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator /= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator %= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator |= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator &= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator #= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator <<= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator >>= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint32 operator + (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator - (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator * (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator / (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator % (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator | (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator & (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator # (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator << (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator >> (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] signum_integer]
genus int64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio int64 operator - () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio int64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~int64 operator = (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator += (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator *= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator /= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator %= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator |= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator &= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator #= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator <<= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator >>= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int64 operator + (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator - (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator * (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator / (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator % (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator | (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator & (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator # (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator << (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator >> (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer]
genus nint64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio nint64 operator - () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio nint64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~nint64 operator = (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator += (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator *= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator /= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator %= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator |= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator &= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator #= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator <<= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator >>= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint64 operator + (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator - (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator * (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator / (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator % (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator | (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator & (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator # (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator << (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator >> (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] signum_integer]
genus intadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio intadl operator - () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio intadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~intadl operator = (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator += (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator *= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator /= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator %= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator |= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator &= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator #= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator <<= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator >>= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio intadl operator + (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator - (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator * (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator / (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator % (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator | (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator & (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator # (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator << (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator >> (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer]
genus nintadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio nintadl operator - () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio nintadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~nintadl operator = (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator += (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator *= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator /= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator %= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator |= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator &= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator #= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator <<= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator >>= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nintadl operator + (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator - (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator * (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator / (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator % (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator | (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator & (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator # (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator << (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator >> (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] fractus]
genus frac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[importa] "fpu_32_neg"] [[nullum_thiscall]] functio frac operator - ();
	[[importa] "fpu_32_non"] [[nullum_thiscall]] functio logicum operator ! ();
	[[xa]] functio ~frac operator = (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[importa] "fpu_32_lsm"] [[nullum_thiscall]] functio ~frac operator += (frac src);
	[[importa] "fpu_32_lsb"] [[nullum_thiscall]] functio ~frac operator -= (frac src);
	[[importa] "fpu_32_lml"] [[nullum_thiscall]] functio ~frac operator *= (frac src);
	[[importa] "fpu_32_ldv"] [[nullum_thiscall]] functio ~frac operator /= (frac src);
	[[importa] "fpu_32_inc"] [[nullum_thiscall]] functio ~frac operator ++ ();
	[[importa] "fpu_32_dec"] [[nullum_thiscall]] functio ~frac operator -- ();
	[[importa] "fpu_32_sum"] [[nullum_thiscall]] classis functio frac operator + (frac a, frac b);
	[[importa] "fpu_32_sub"] [[nullum_thiscall]] classis functio frac operator - (frac a, frac b);
	[[importa] "fpu_32_mul"] [[nullum_thiscall]] classis functio frac operator * (frac a, frac b);
	[[importa] "fpu_32_div"] [[nullum_thiscall]] classis functio frac operator / (frac a, frac b);
	[[importa] "fpu_32_par"] [[nullum_thiscall]] classis functio logicum operator == (frac a, frac b);
	[[importa] "fpu_32_npr"] [[nullum_thiscall]] classis functio logicum operator != (frac a, frac b);
	[[importa] "fpu_32_min"] [[nullum_thiscall]] classis functio logicum operator < (frac a, frac b);
	[[importa] "fpu_32_maj"] [[nullum_thiscall]] classis functio logicum operator > (frac a, frac b);
	[[importa] "fpu_32_pmn"] [[nullum_thiscall]] classis functio logicum operator <= (frac a, frac b);
	[[importa] "fpu_32_pmj"] [[nullum_thiscall]] classis functio logicum operator >= (frac a, frac b);
}
[[innatum]] [[magnitudo] "8"] [[significatio] fractus]
genus dfrac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[importa] "fpu_64_neg"] [[nullum_thiscall]] functio dfrac operator - ();
	[[importa] "fpu_64_non"] [[nullum_thiscall]] functio logicum operator ! ();
	[[xa]] functio ~dfrac operator = (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[importa] "fpu_64_lsm"] [[nullum_thiscall]] functio ~dfrac operator += (dfrac src);
	[[importa] "fpu_64_lsb"] [[nullum_thiscall]] functio ~dfrac operator -= (dfrac src);
	[[importa] "fpu_64_lml"] [[nullum_thiscall]] functio ~dfrac operator *= (dfrac src);
	[[importa] "fpu_64_ldv"] [[nullum_thiscall]] functio ~dfrac operator /= (dfrac src);
	[[importa] "fpu_64_inc"] [[nullum_thiscall]] functio ~dfrac operator ++ ();
	[[importa] "fpu_64_dec"] [[nullum_thiscall]] functio ~dfrac operator -- ();
	[[importa] "fpu_64_sum"] [[nullum_thiscall]] classis functio dfrac operator + (dfrac a, dfrac b);
	[[importa] "fpu_64_sub"] [[nullum_thiscall]] classis functio dfrac operator - (dfrac a, dfrac b);
	[[importa] "fpu_64_mul"] [[nullum_thiscall]] classis functio dfrac operator * (dfrac a, dfrac b);
	[[importa] "fpu_64_div"] [[nullum_thiscall]] classis functio dfrac operator / (dfrac a, dfrac b);
	[[importa] "fpu_64_par"] [[nullum_thiscall]] classis functio logicum operator == (dfrac a, dfrac b);
	[[importa] "fpu_64_npr"] [[nullum_thiscall]] classis functio logicum operator != (dfrac a, dfrac b);
	[[importa] "fpu_64_min"] [[nullum_thiscall]] classis functio logicum operator < (dfrac a, dfrac b);
	[[importa] "fpu_64_maj"] [[nullum_thiscall]] classis functio logicum operator > (dfrac a, dfrac b);
	[[importa] "fpu_64_pmn"] [[nullum_thiscall]] classis functio logicum operator <= (dfrac a, dfrac b);
	[[importa] "fpu_64_pmj"] [[nullum_thiscall]] classis functio logicum operator >= (dfrac a, dfrac b);
}

nomen_alternum int = int32;
nomen_alternum nint = nint32;
nomen_alternum frac32 = frac;
nomen_alternum frac64 = dfrac;
nomen_alternum char = nint32;

dura logicum {
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_l_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_l_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_i8_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i8_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[importa] "fpu_n8_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n8_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[importa] "fpu_i16_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i16_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[importa] "fpu_n16_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n16_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[importa] "fpu_i32_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i32_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[importa] "fpu_n32_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n32_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura int64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[importa] "fpu_i64_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_i64_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nint64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[importa] "fpu_n64_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_n64_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura intadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[importa] "fpu_iadl_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_iadl_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura nintadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[importa] "fpu_nadl_ad_f32"] [[nullum_thiscall]] convertor (frac) ();
	[[importa] "fpu_nadl_ad_f64"] [[nullum_thiscall]] convertor (dfrac) ();
}
dura frac {
	[[importa] "fpu_f32_ad_l"]		[[nullum_thiscall]] convertor (logicum) ();
	[[importa] "fpu_f32_ad_i8"]		[[nullum_thiscall]] convertor (int8) ();
	[[importa] "fpu_f32_ad_n8"]		[[nullum_thiscall]] convertor (nint8) ();
	[[importa] "fpu_f32_ad_i16"]	[[nullum_thiscall]] convertor (int16) ();
	[[importa] "fpu_f32_ad_n16"]	[[nullum_thiscall]] convertor (nint16) ();
	[[importa] "fpu_f32_ad_i32"]	[[nullum_thiscall]] convertor (int32) ();
	[[importa] "fpu_f32_ad_n32"]	[[nullum_thiscall]] convertor (nint32) ();
	[[importa] "fpu_f32_ad_i64"]	[[nullum_thiscall]] convertor (int64) ();
	[[importa] "fpu_f32_ad_n64"]	[[nullum_thiscall]] convertor (nint64) ();
	[[importa] "fpu_f32_ad_iadl"]	[[nullum_thiscall]] convertor (intadl) ();
	[[importa] "fpu_f32_ad_nadl"]	[[nullum_thiscall]] convertor (nintadl) ();
	[[importa] "fpu_f32_ad_f64"]	[[nullum_thiscall]] convertor (dfrac) ();
}
dura dfrac {
	[[importa] "fpu_f64_ad_l"]		[[nullum_thiscall]] convertor (logicum) ();
	[[importa] "fpu_f64_ad_i8"]		[[nullum_thiscall]] convertor (int8) ();
	[[importa] "fpu_f64_ad_n8"]		[[nullum_thiscall]] convertor (nint8) ();
	[[importa] "fpu_f64_ad_i16"]	[[nullum_thiscall]] convertor (int16) ();
	[[importa] "fpu_f64_ad_n16"]	[[nullum_thiscall]] convertor (nint16) ();
	[[importa] "fpu_f64_ad_i32"]	[[nullum_thiscall]] convertor (int32) ();
	[[importa] "fpu_f64_ad_n32"]	[[nullum_thiscall]] convertor (nint32) ();
	[[importa] "fpu_f64_ad_i64"]	[[nullum_thiscall]] convertor (int64) ();
	[[importa] "fpu_f64_ad_n64"]	[[nullum_thiscall]] convertor (nint64) ();
	[[importa] "fpu_f64_ad_iadl"]	[[nullum_thiscall]] convertor (intadl) ();
	[[importa] "fpu_f64_ad_nadl"]	[[nullum_thiscall]] convertor (nintadl) ();
	[[importa] "fpu_f64_ad_f32"]	[[nullum_thiscall]] convertor (frac) ();
}

[[xa]] functio logicum operator == (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
}
[[xa]] functio logicum operator != (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
}

spatium math {
	dura .frac {
		constatus pi = frac(3.14159265358979323846);
		constatus e = frac(2.71828182845904523536);
	}
	dura .dfrac {
		constatus pi = 3.14159265358979323846;
		constatus e = 2.71828182845904523536;
	}
	spatium casualis {
		[[importa] fpu_ncg_1]	functio nihil data(@nihil data, int long);
		[[importa] fpu_ncg_2]	functio int integer(int min, int max);
		[[importa] fpu_ncg_3]	functio dfrac fractus();
	}

	[[importa] fpu_f32_pi]	functio frac inf_pos_s();
	[[importa] fpu_f32_ni]	functio frac inf_neg_s();
	[[importa] fpu_f32_nn]	functio frac nn_s();
	[[importa] fpu_f64_pi]	functio dfrac inf_pos_d();
	[[importa] fpu_f64_ni]	functio dfrac inf_neg_d();
	[[importa] fpu_f64_nn]	functio dfrac nn_d();
	[[importa] fpu_ei_32]	functio logicum est_inf(frac valor);
	[[importa] fpu_ei_64]	functio logicum est_inf(dfrac valor);
	[[importa] fpu_enn_32]	functio logicum est_nn(frac valor);
	[[importa] fpu_enn_64]	functio logicum est_nn(dfrac valor);

	[[importa] fpu_abs_i8]	functio int8	abs(int8 valor);
	[[importa] fpu_abs_i16]	functio int16	abs(int16 valor);
	[[importa] fpu_abs_i32]	functio int32	abs(int32 valor);
	[[importa] fpu_abs_i64]	functio int64	abs(int64 valor);
	[[importa] fpu_abs_iad]	functio intadl	abs(intadl valor);
	[[importa] fpu_abs_f32]	functio frac	abs(frac valor);
	[[importa] fpu_abs_f64]	functio dfrac	abs(dfrac valor);

	[[importa] fpu_sgn_i8]	functio int8	sgn(int8 valor);
	[[importa] fpu_sgn_i16]	functio int16	sgn(int16 valor);
	[[importa] fpu_sgn_i32]	functio int32	sgn(int32 valor);
	[[importa] fpu_sgn_i64]	functio int64	sgn(int64 valor);
	[[importa] fpu_sgn_iad]	functio intadl	sgn(intadl valor);
	[[importa] fpu_sgn_f32]	functio frac	sgn(frac valor);
	[[importa] fpu_sgn_f64]	functio dfrac	sgn(dfrac valor);

	[[importa] fpu_c1]		functio frac	concava(frac valor);
	[[importa] fpu_c1_d]	functio dfrac	concava(dfrac valor);
	[[importa] fpu_c2]		functio frac	trunca(frac valor);
	[[importa] fpu_c2_d]	functio dfrac	trunca(dfrac valor);
	[[importa] fpu_c3]		functio frac	solum(frac valor);
	[[importa] fpu_c3_d]	functio dfrac	solum(dfrac valor);
	[[importa] fpu_c4]		functio frac	tectum(frac valor);
	[[importa] fpu_c4_d]	functio dfrac	tectum(dfrac valor);

	[[importa] fpu_rdx]		functio frac	radix(frac valor);
	[[importa] fpu_rdx_d]	functio dfrac	radix(dfrac valor);
	[[importa] fpu_pot]		functio frac	pot(frac valor, frac pot);
	[[importa] fpu_pot_d]	functio dfrac	pot(dfrac valor, dfrac pot);

	[[importa] fpu_exp]		functio frac	exp(frac valor);
	[[importa] fpu_exp_d]	functio dfrac	exp(dfrac valor);
	[[importa] fpu_ln]		functio frac	ln(frac valor);
	[[importa] fpu_ln_d]	functio dfrac	ln(dfrac valor);
	[[importa] fpu_lb]		functio frac	lb(frac valor);
	[[importa] fpu_lb_d]	functio dfrac	lb(dfrac valor);
	[[importa] fpu_lg]		functio frac	lg(frac valor);
	[[importa] fpu_lg_d]	functio dfrac	lg(dfrac valor);

	[[importa] fpu_sin]		functio frac	sin(frac valor);
	[[importa] fpu_sin_d]	functio dfrac	sin(dfrac valor);
	[[importa] fpu_cos]		functio frac	cos(frac valor);
	[[importa] fpu_cos_d]	functio dfrac	cos(dfrac valor);
	[[importa] fpu_tg]		functio frac	tg(frac valor);
	[[importa] fpu_tg_d]	functio dfrac	tg(dfrac valor);
	[[importa] fpu_ctg]		functio frac	ctg(frac valor);
	[[importa] fpu_ctg_d]	functio dfrac	ctg(dfrac valor);

	[[importa] fpu_asin]	functio frac	arcsin(frac valor);
	[[importa] fpu_asin_d]	functio dfrac	arcsin(dfrac valor);
	[[importa] fpu_acos]	functio frac	arccos(frac valor);
	[[importa] fpu_acos_d]	functio dfrac	arccos(dfrac valor);
	[[importa] fpu_atg]		functio frac	arctg(frac valor);
	[[importa] fpu_atg_d]	functio dfrac	arctg(dfrac valor);
	[[importa] fpu_actg]	functio frac	arcctg(frac valor);
	[[importa] fpu_actg_d]	functio dfrac	arcctg(dfrac valor);
}
spatium memoria {
	[[importa] alloca_memoriam]		functio @nihil alloca(nintadl magn);
	[[importa] realloca_memoriam]	functio @nihil realloca(@nihil mem, nintadl magn);
	[[importa] dimitte_memoriam]	functio nihil dimitte(@nihil mem);
}
spatium errores {
	[error] constatus error_nullus		= 0x00;
	[error] constatus implantatio_nulla	= 0x01;
	[error] constatus memoria_nulla		= 0x02;
	[error] constatus argumentum_falsum	= 0x03;
	[error] constatus efformatio_falsa	= 0x04;
	[error] constatus habitus_falsus	= 0x05;
	[error] constatus ie_falsum			= 0x06;
	[error] constatus xe_defectus		= 0x07;

	[sub_error ie_falsum] constatus ie_error_nullus					= 0x00;
	[sub_error ie_falsum] constatus ie_error_ignotus				= 0x01;
	[sub_error ie_falsum] constatus ie_lima_nulla					= 0x02;
	[sub_error ie_falsum] constatus ie_semita_nulla					= 0x03;
	[sub_error ie_falsum] constatus ie_nimium_limae_apertae			= 0x04;
	[sub_error ie_falsum] constatus ie_permissio_nulla				= 0x05;
	[sub_error ie_falsum] constatus ie_manubrium_defectum			= 0x06;
	[sub_error ie_falsum] constatus ie_memoria_nulla				= 0x07;
	[sub_error ie_falsum] constatus ie_machinatio_defecta			= 0x08;
	[sub_error ie_falsum] constatus ie_sole_legere					= 0x09;
	[sub_error ie_falsum] constatus ie_spatium_disci_nullum			= 0x0A;
	[sub_error ie_falsum] constatus ie_lima_preexistat				= 0x0B;
	[sub_error ie_falsum] constatus ie_implantatio_nulla			= 0x0C;
	[sub_error ie_falsum] constatus ie_collectorium_non_vacuum		= 0x0D;
	[sub_error ie_falsum] constatus ie_collectorium_est_currens		= 0x0E;
	[sub_error ie_falsum] constatus ie_machinatio_non_idem			= 0x0F;
	[sub_error ie_falsum] constatus ie_nomen_semitae_defectum		= 0x10;
	[sub_error ie_falsum] constatus ie_nomen_limae_nimium_largum	= 0x11;
	[sub_error ie_falsum] constatus ie_lima_nimium_larga			= 0x12;
	[sub_error ie_falsum] constatus ie_legere_falsum				= 0x13;
	[sub_error ie_falsum] constatus ie_scribere_falsum				= 0x14;
	[sub_error ie_falsum] constatus ie_creare_falsum				= 0x15;
	[sub_error ie_falsum] constatus ie_aperire_falsum				= 0x16;

	[sub_error xe_defectus] constatus xe_error_nullus			= 0x00;
	[sub_error xe_defectus] constatus xe_modulus_nullus			= 0x01;
	[sub_error xe_defectus] constatus xe_imago_falsa			= 0x02;
	[sub_error xe_defectus] constatus xe_functio_falsa			= 0x03;
	[sub_error xe_defectus] constatus xe_abi_functionis_falsa	= 0x04;
	[sub_error xe_defectus] constatus xe_symbolus_duplicatus	= 0x05;
	[sub_error xe_defectus] constatus xe_adhaesio_defecta		= 0x06;
	[sub_error xe_defectus] constatus xe_importus_falsus		= 0x07;
	[sub_error xe_defectus] constatus xe_librarium_nullum		= 0x08;
	[sub_error xe_defectus] constatus xe_lib_importus_falsus	= 0x09;
	[sub_error xe_defectus] constatus xe_allocatus_defectus		= 0x0A;
	[sub_error xe_defectus] constatus xe_initium_defectum		= 0x0B;
}

genus linea {
	@nihil _data;
	int longitudo { [[importa] "spu_long"] [[nullum_thiscall]] adipisce; }

	functio int initus() { responde 0; }
	functio int finis() { responde longitudo - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde longitudo; }

	constatus radix_bina		= "01";
	constatus radix_octava		= "01234567";
	constatus radix_decima		= "0123456789";
	constatus radix_sextadecima	= "0123456789ABCDEF";

	constatus codex_ignotus		= 0x00;
	constatus codex_ascii		= 0x01;
	constatus codex_utf8		= 0x02;
	constatus codex_utf16		= 0x03;
	constatus codex_utf32		= 0x04;

	structor () { _data = nullus; }
	structor motus (~linea s) { _data = s._data; s._data = nullus; }
	destructor () { memoria.dimitte(_data); }

	[[importa] "spu_crea"]			[[nullum_thiscall]] structor (~linea valor) iacit;
	[[importa] "spu_crea_utf32"]	[[nullum_thiscall]] structor (@char valor) iacit;
	[[importa] "spu_crea_int8"]		[[nullum_thiscall]] structor (int8 valor) iacit;
	[[importa] "spu_crea_nint8"]	[[nullum_thiscall]] structor (nint8 valor) iacit;
	[[importa] "spu_crea_int16"]	[[nullum_thiscall]] structor (int16 valor) iacit;
	[[importa] "spu_crea_nint16"]	[[nullum_thiscall]] structor (nint16 valor) iacit;
	[[importa] "spu_crea_int32"]	[[nullum_thiscall]] structor (int32 valor) iacit;
	[[importa] "spu_crea_nint32"]	[[nullum_thiscall]] structor (nint32 valor) iacit;
	[[importa] "spu_crea_int64"]	[[nullum_thiscall]] structor (int64 valor) iacit;
	[[importa] "spu_crea_nint64"]	[[nullum_thiscall]] structor (nint64 valor) iacit;
	[[importa] "spu_crea_intadl"]	[[nullum_thiscall]] structor (intadl valor) iacit;
	[[importa] "spu_crea_nintadl"]	[[nullum_thiscall]] structor (nintadl valor) iacit;
	[[importa] "spu_crea_frac32"]	[[nullum_thiscall]] structor (frac valor) iacit;
	[[importa] "spu_crea_frac64"]	[[nullum_thiscall]] structor (dfrac valor) iacit;
	[[importa] "spu_crea_logicum"]	[[nullum_thiscall]] structor (logicum valor) iacit;
	[[importa] "spu_crea_char"]		[[nullum_thiscall]] structor (char valor, int long) iacit;
	[[importa] "spu_crea_adl"]		[[nullum_thiscall]] structor (@nihil valor) iacit;
	[[importa] "spu_crea_data"]		[[nullum_thiscall]] structor (@nihil valor, int long, int codex) iacit;
	[[importa] "spu_loca"]			[[nullum_thiscall]] functio ~linea operator = (~linea valor) iacit;
	[[importa] "spu_loca_utf32"]	[[nullum_thiscall]] functio ~linea operator = (@char valor) iacit;
	[[importa] "spu_concat"]		[[nullum_thiscall]] functio ~linea operator += (~linea valor) iacit;
	[[importa] "spu_index"]			[[nullum_thiscall]] functio char operator [] (int index);

	[[importa] "spu_crea_nint32_radix"]		[[nullum_thiscall]] structor (nint32 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nint64_radix"]		[[nullum_thiscall]] structor (nint64 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nintadl_radix"]	[[nullum_thiscall]] structor (nintadl valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_frac32_2"]			[[nullum_thiscall]] structor (frac valor, char punctum) iacit;
	[[importa] "spu_crea_frac32_3"]			[[nullum_thiscall]] structor (frac valor, char punctum, int long) iacit;
	[[importa] "spu_crea_frac64_2"]			[[nullum_thiscall]] structor (dfrac valor, char punctum) iacit;
	[[importa] "spu_crea_frac64_3"]			[[nullum_thiscall]] structor (dfrac valor, char punctum, int long) iacit;

	[[importa] "spu_concat_classis"]	classis functio linea operator + (~linea a, ~linea b) iacit;
	[[importa] "spu_compareo"]			classis functio int operator <=> (~linea a, ~linea b);
	[[importa] "spu_compareo_2"]		classis functio int operator # (~linea a, ~linea b);

	classis functio logicum operator == (~linea a, ~linea b) iacit { responde a <=> b == 0; }
	classis functio logicum operator != (~linea a, ~linea b) iacit { responde a <=> b != 0; }
	classis functio logicum operator <= (~linea a, ~linea b) iacit { responde a <=> b <= 0; }
	classis functio logicum operator >= (~linea a, ~linea b) iacit { responde a <=> b >= 0; }
	classis functio logicum operator < (~linea a, ~linea b) iacit { responde a <=> b < 0; }
	classis functio logicum operator > (~linea a, ~linea b) iacit { responde a <=> b > 0; }

	[[importa] "spu_reperi_primus"]		[[nullum_thiscall]] functio int reperi_primus(~linea valor);
	[[importa] "spu_reperi_ultimus"]	[[nullum_thiscall]] functio int reperi_ultimus(~linea valor);
	[[importa] "spu_fragmentum"]		[[nullum_thiscall]] functio linea fragmentum(int primus, int long) iacit;
	[[importa] "spu_surroga"]			[[nullum_thiscall]] functio linea surroga(~linea sublinea, ~linea cum) iacit;
	[[importa] "spu_codex_long"]		[[nullum_thiscall]] functio int longitudo_codicis(int codex) iacit;
	[[importa] "spu_codifica"]			[[nullum_thiscall]] functio nihil codifica(@nihil data, int codex, logicum termina) iacit;
	
	[[importa] "spu_ad_int32"]			[[nullum_thiscall]] functio int32 ad_int32() iacit;
	[[importa] "spu_ad_int32_2"]		[[nullum_thiscall]] functio int32 ad_int32(~linea radix) iacit;
	[[importa] "spu_ad_int32_3"]		[[nullum_thiscall]] functio int32 ad_int32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint32"]			[[nullum_thiscall]] functio nint32 ad_nint32() iacit;
	[[importa] "spu_ad_nint32_2"]		[[nullum_thiscall]] functio nint32 ad_nint32(~linea radix) iacit;
	[[importa] "spu_ad_nint32_3"]		[[nullum_thiscall]] functio nint32 ad_nint32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_int64"]			[[nullum_thiscall]] functio int64 ad_int64() iacit;
	[[importa] "spu_ad_int64_2"]		[[nullum_thiscall]] functio int64 ad_int64(~linea radix) iacit;
	[[importa] "spu_ad_int64_3"]		[[nullum_thiscall]] functio int64 ad_int64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint64"]			[[nullum_thiscall]] functio nint64 ad_nint64() iacit;
	[[importa] "spu_ad_nint64_2"]		[[nullum_thiscall]] functio nint64 ad_nint64(~linea radix) iacit;
	[[importa] "spu_ad_nint64_3"]		[[nullum_thiscall]] functio nint64 ad_nint64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_frac32"]			[[nullum_thiscall]] functio frac ad_frac() iacit;
	[[importa] "spu_ad_frac32_2"]		[[nullum_thiscall]] functio frac ad_frac(~linea punctum) iacit;
	[[importa] "spu_ad_frac64"]			[[nullum_thiscall]] functio dfrac ad_dfrac() iacit;
	[[importa] "spu_ad_frac64_2"]		[[nullum_thiscall]] functio dfrac ad_dfrac(~linea punctum) iacit;

	[[importa] "spu_forma_0"] classis functio linea forma(~linea schema, ~linea a0) iacit;
	[[importa] "spu_forma_1"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1) iacit;
	[[importa] "spu_forma_2"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2) iacit;
	[[importa] "spu_forma_3"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3) iacit;
	[[importa] "spu_forma_4"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4) iacit;
	[[importa] "spu_forma_5"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5) iacit;
	[[importa] "spu_forma_6"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6) iacit;
	[[importa] "spu_forma_7"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7) iacit;
	[[importa] "spu_forma_8"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8) iacit;
	[[importa] "spu_forma_9"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8, ~linea a9) iacit;

	linea inferna	{ [[importa] "spu_inferna"]	[[nullum_thiscall]] adipisce iacit; }
	linea supera	{ [[importa] "spu_supera"]	[[nullum_thiscall]] adipisce iacit; }
}

spatium errores {
	[[importa] descriptio_erroris] functio nihil _descriptio_erroris(nintadl ec, nintadl esc, @nihil mdl, ~linea error, ~linea sub_error);
	functio nihil descriptio(nintadl ec, nintadl esc, ~linea error, ~linea sub_error) { _descriptio_erroris(ec, esc, modulus(), error, sub_error); }
}
spatium actuarius {
	protocollum _actuarius { functio nihil scribe(~linea ln) virtualis pura; }
	functio nihil scribe(~linea ln) { (@_actuarius)(protocollum(actuarius))^.scribe(ln); }
}

// TODO: REWORK

genus virtualis objectum {
	nintadl _num_ref;
	functio nint contine() virtualis pura;
	functio nint dimitte() virtualis pura;
	destructor () virtualis {}
	functio linea ad_linea() virtualis pura;
}

dura linea {
	[[importa] "spu_codifica_taleam"]	[[nullum_thiscall]] functio @objectum codifica(int codex, logicum termina) iacit;
	[[importa] "spu_scinde"]			[[nullum_thiscall]] functio @objectum scinde(char) iacit;
}