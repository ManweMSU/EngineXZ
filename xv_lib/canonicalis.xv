auxilium attributum ("NomenModuli") = "Liber Canonicalis";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2025";
auxilium attributum ("Versio") = "1.0.0.1";

auxilium versio 0;

[[systema] libera]

[[innatum]] [[magnitudo] "0"] [[significatio] nihil]
genus nihil {}

[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus logicum {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (logicum src) {
		INTERFACE W 1 : THIS 1 => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio logicum operator - () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ~ () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~logicum operator = (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator |= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator &= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator #= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio logicum operator | (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator & (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator # (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @SAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTSAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer_signus]
genus int8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio int8 operator - () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio int8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~int8 operator = (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator += (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator *= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator /= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator %= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator |= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator &= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator #= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator <<= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator >>= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int8 operator + (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator - (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator * (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator / (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator % (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator | (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator & (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator # (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator << (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator >> (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus nint8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio nint8 operator - () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio nint8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~nint8 operator = (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator += (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator *= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator /= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator %= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator |= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator &= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator #= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator <<= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator >>= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint8 operator + (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator - (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator * (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator / (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator % (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator | (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator & (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator # (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator << (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator >> (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer_signus]
genus int16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio int16 operator - () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio int16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~int16 operator = (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator += (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator *= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator /= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator %= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator |= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator &= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator #= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator <<= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator >>= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int16 operator + (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator - (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator * (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator / (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator % (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator | (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator & (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator # (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator << (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator >> (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer]
genus nint16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio nint16 operator - () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio nint16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~nint16 operator = (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator += (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator *= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator /= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator %= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator |= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator &= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator #= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator <<= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator >>= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint16 operator + (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator - (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator * (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator / (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator % (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator | (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator & (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator # (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator << (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator >> (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer_signus]
genus int32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio int32 operator - () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio int32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~int32 operator = (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator += (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator *= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator /= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator %= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator |= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator &= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator #= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator <<= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator >>= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int32 operator + (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator - (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator * (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator / (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator % (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator | (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator & (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator # (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator << (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator >> (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer]
genus nint32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio nint32 operator - () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio nint32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~nint32 operator = (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator += (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator *= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator /= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator %= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator |= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator &= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator #= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator <<= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator >>= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint32 operator + (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator - (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator * (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator / (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator % (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator | (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator & (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator # (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator << (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator >> (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer_signus]
genus int64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio int64 operator - () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio int64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~int64 operator = (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator += (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator *= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator /= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator %= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator |= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator &= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator #= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator <<= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator >>= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int64 operator + (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator - (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator * (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator / (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator % (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator | (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator & (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator # (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator << (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator >> (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer]
genus nint64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio nint64 operator - () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio nint64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~nint64 operator = (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator += (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator *= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator /= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator %= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator |= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator &= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator #= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator <<= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator >>= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint64 operator + (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator - (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator * (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator / (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator % (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator | (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator & (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator # (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator << (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator >> (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer_signus]
genus intadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio intadl operator - () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio intadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~intadl operator = (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator += (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator *= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator /= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator %= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator |= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator &= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator #= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator <<= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator >>= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio intadl operator + (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator - (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator * (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator / (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator % (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator | (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator & (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator # (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator << (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator >> (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer]
genus nintadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio nintadl operator - () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio nintadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~nintadl operator = (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator += (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator *= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator /= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator %= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator |= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator &= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator #= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator <<= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator >>= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nintadl operator + (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator - (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator * (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator / (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator % (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator | (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator & (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator # (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator << (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator >> (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] fractus]
genus frac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] [[inline]] functio frac operator - () { INTERFACE W 1 : THIS => 4 : FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_NEG_32:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } } }
	[[xa]] [[inline]] functio logicum operator ! () { INTERFACE W 1 : THIS => 1 CODE { RET { @BLT:1 1=>1(R, @FP_ZERO_32:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } } }
	[[xa]] functio ~frac operator = (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator += (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_ADD_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator -= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_SUB_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator *= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_MUL_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator /= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_DIV_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator ++ () {
		DATA DWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_ADD_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator -- () {
		DATA DWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_SUB_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] [[inline]] classis functio frac operator + (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_ADD_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator - (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_SUB_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator * (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_MUL_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator / (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_DIV_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator == (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_EQ_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator != (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NEQ_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator < (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_L_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator > (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_G_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator <= (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_LE_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator >= (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_GE_32:4 4=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] fractus]
genus dfrac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] [[inline]] functio dfrac operator - () { INTERFACE W 1 : THIS => 8 : FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_NEG_64:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } } }
	[[xa]] [[inline]] functio logicum operator ! () { INTERFACE W 1 : THIS => 1 CODE { RET { @BLT:1 1=>1(R, @FP_ZERO_64:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } } }
	[[xa]] functio ~dfrac operator = (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator += (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_ADD_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator -= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_SUB_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator *= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_MUL_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator /= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_DIV_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator ++ () {
		DATA QWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_ADD_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator -- () {
		DATA QWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_SUB_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator + (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_ADD_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator - (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_SUB_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator * (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_MUL_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator / (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_DIV_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator == (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_EQ_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator != (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NEQ_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator < (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_L_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator > (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_G_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator <= (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_LE_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator >= (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_GE_64:8 8=>1(A[0], A[1])) } }
	}
}

nomen_alternum int = int32;
nomen_alternum nint = nint32;
nomen_alternum frac32 = frac;
nomen_alternum frac64 = dfrac;
nomen_alternum char = nint32;

dura logicum {
	[[xa]] [[convertor] "extendens"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:INT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:INT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura int8 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:SINT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:SINT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura nint8 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:INT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:INT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura int16 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:2:SINT=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:2:SINT=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
}
dura nint16 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:2:INT=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:2:INT=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
}
dura int32 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:4:SINT=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:4:SINT=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura nint32 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:4:INT=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens:pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:4:INT=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura int64 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:8:SINT=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:8:SINT=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}
dura nint64 {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:8:INT=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:8:INT=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}
dura intadl {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:W 1:SINT=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:W 1:SINT=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
}
dura nintadl {
	[[xa]] [[convertor] "angustans"] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "conformis"] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:W 1:INT=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:W 1:INT=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
}
dura frac {
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NOTZERO_32:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_32:4=>1:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : INT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_32:4=>1:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_32:4=>2:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : INT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_32:4=>2:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_32:4=>4:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : INT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_32:4=>4:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_32:4=>8:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : INT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_32:4=>8:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_32:4=>W 1:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : INT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_32:4=>W 1:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[convertor] "extendens"] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_RESIZE_32:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura dfrac {
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NOTZERO_64:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_64:8=>1:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : INT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_64:8=>1:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_64:8=>2:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans:pretiosus"] [[inline]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : INT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_64:8=>2:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_64:8=>4:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : INT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_64:8=>4:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_64:8=>8:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : INT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_64:8=>8:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_64:8=>W 1:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "pretiosus"] [[inline]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : INT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_64:8=>W 1:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[convertor] "angustans"] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_RESIZE_64:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}

[[xa]] functio logicum operator == (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
}
[[xa]] functio logicum operator != (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
}

spatium math {
	dura .frac {
		constatus pi = frac(3.14159265358979323846);
		constatus e = frac(2.71828182845904523536);
	}
	dura .dfrac {
		constatus pi = 3.14159265358979323846;
		constatus e = 2.71828182845904523536;
	}
	spatium caecus {
		[[importa] fpu_ncg_1]	functio nihil data(@nihil data, int long);
		[[importa] fpu_ncg_2]	functio int integer(int min, int max);
		[[importa] fpu_ncg_3]	functio dfrac fractus();
	}

	[[importa] fpu_f32_pi]	functio frac inf_pos_s();
	[[importa] fpu_f32_ni]	functio frac inf_neg_s();
	[[importa] fpu_f32_nn]	functio frac nn_s();
	[[importa] fpu_f64_pi]	functio dfrac inf_pos_d();
	[[importa] fpu_f64_ni]	functio dfrac inf_neg_d();
	[[importa] fpu_f64_nn]	functio dfrac nn_d();
	[[importa] fpu_ei_32]	functio logicum inf_est(frac valor);
	[[importa] fpu_ei_64]	functio logicum inf_est(dfrac valor);
	[[importa] fpu_enn_32]	functio logicum nn_est(frac valor);
	[[importa] fpu_enn_64]	functio logicum nn_est(dfrac valor);

	[[xa]] [[inline]]		functio int8	abs(int8 valor)		{ INTERFACE 1:SINT=>1:SINT CODE { RET { @BLT:1 1=>1(R, @ABS:1=>1(A[0])) } } }
	[[xa]] [[inline]]		functio int16	abs(int16 valor)	{ INTERFACE 2:SINT=>2:SINT CODE { RET { @BLT:2 2=>2(R, @ABS:2=>2(A[0])) } } }
	[[xa]] [[inline]]		functio int32	abs(int32 valor)	{ INTERFACE 4:SINT=>4:SINT CODE { RET { @BLT:4 4=>4(R, @ABS:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio int64	abs(int64 valor)	{ INTERFACE 8:SINT=>8:SINT CODE { RET { @BLT:8 8=>8(R, @ABS:8=>8(A[0])) } } }
	[[xa]] [[inline]]		functio intadl	abs(intadl valor)	{ INTERFACE W 1:SINT=>W 1:SINT CODE { RET { @BLT:W 1 W 1=>W 1(R, @ABS:W 1=>W 1(A[0])) } } }
	[[xa]] [[inline]]		functio frac	abs(frac valor)		{ INTERFACE 4:FLOAT=>4:FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_ABS_32:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio dfrac	abs(dfrac valor)	{ INTERFACE 8:FLOAT=>8:FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_ABS_64:8=>8(A[0])) } } }

	[[importa] fpu_sgn_i8]	functio int8	sgn(int8 valor);
	[[importa] fpu_sgn_i16]	functio int16	sgn(int16 valor);
	[[importa] fpu_sgn_i32]	functio int32	sgn(int32 valor);
	[[importa] fpu_sgn_i64]	functio int64	sgn(int64 valor);
	[[importa] fpu_sgn_iad]	functio intadl	sgn(intadl valor);
	[[importa] fpu_sgn_f32]	functio frac	sgn(frac valor);
	[[importa] fpu_sgn_f64]	functio dfrac	sgn(dfrac valor);

	[[importa] fpu_c1]		functio frac	concava(frac valor);
	[[importa] fpu_c1_d]	functio dfrac	concava(dfrac valor);
	[[importa] fpu_c2]		functio frac	trunca(frac valor);
	[[importa] fpu_c2_d]	functio dfrac	trunca(dfrac valor);
	[[importa] fpu_c3]		functio frac	solum(frac valor);
	[[importa] fpu_c3_d]	functio dfrac	solum(dfrac valor);
	[[importa] fpu_c4]		functio frac	tectum(frac valor);
	[[importa] fpu_c4_d]	functio dfrac	tectum(dfrac valor);

	[[xa]] [[inline]]		functio frac	radix(frac valor)	{ INTERFACE 4:FLOAT=>4:FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_SQRT_32:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio dfrac	radix(dfrac valor)	{ INTERFACE 8:FLOAT=>8:FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_SQRT_64:8=>8(A[0])) } } }
	[[importa] fpu_pot]		functio frac	pot(frac valor, frac pot);
	[[importa] fpu_pot_d]	functio dfrac	pot(dfrac valor, dfrac pot);

	[[importa] fpu_exp]		functio frac	exp(frac valor);
	[[importa] fpu_exp_d]	functio dfrac	exp(dfrac valor);
	[[importa] fpu_ln]		functio frac	ln(frac valor);
	[[importa] fpu_ln_d]	functio dfrac	ln(dfrac valor);
	[[importa] fpu_lb]		functio frac	lb(frac valor);
	[[importa] fpu_lb_d]	functio dfrac	lb(dfrac valor);
	[[importa] fpu_lg]		functio frac	lg(frac valor);
	[[importa] fpu_lg_d]	functio dfrac	lg(dfrac valor);

	[[importa] fpu_sin]		functio frac	sin(frac valor);
	[[importa] fpu_sin_d]	functio dfrac	sin(dfrac valor);
	[[importa] fpu_cos]		functio frac	cos(frac valor);
	[[importa] fpu_cos_d]	functio dfrac	cos(dfrac valor);
	[[importa] fpu_tg]		functio frac	tg(frac valor);
	[[importa] fpu_tg_d]	functio dfrac	tg(dfrac valor);
	[[importa] fpu_ctg]		functio frac	ctg(frac valor);
	[[importa] fpu_ctg_d]	functio dfrac	ctg(dfrac valor);

	[[importa] fpu_asin]	functio frac	arcsin(frac valor);
	[[importa] fpu_asin_d]	functio dfrac	arcsin(dfrac valor);
	[[importa] fpu_acos]	functio frac	arccos(frac valor);
	[[importa] fpu_acos_d]	functio dfrac	arccos(dfrac valor);
	[[importa] fpu_atg]		functio frac	arctg(frac valor);
	[[importa] fpu_atg_d]	functio dfrac	arctg(dfrac valor);
	[[importa] fpu_actg]	functio frac	arcctg(frac valor);
	[[importa] fpu_actg_d]	functio dfrac	arcctg(dfrac valor);
}
spatium memoria {
	[[importa] alloca_memoriam]		functio @nihil alloca(nintadl magn);
	[[importa] realloca_memoriam]	functio @nihil realloca(@nihil mem, nintadl magn);
	[[importa] dimitte_memoriam]	functio nihil dimitte(@nihil mem);
	[[importa] relabe_memoriam]		functio nihil relabe(@nihil mem, nintadl magn);
	[[importa] exscribe_memoriam]	functio @nihil exscribe(@nihil in, @nihil ex, nintadl magn);
}
spatium errores {
	[error] constatus error_nullus		= 0x00;
	[error] constatus implantatio_nulla	= 0x01;
	[error] constatus memoria_nulla		= 0x02;
	[error] constatus argumentum_falsum	= 0x03;
	[error] constatus efformatio_falsa	= 0x04;
	[error] constatus habitus_falsus	= 0x05;
	[error] constatus ie_falsum			= 0x06;
	[error] constatus xe_defectus		= 0x07;

	[sub_error ie_falsum] constatus ie_error_nullus					= 0x00;
	[sub_error ie_falsum] constatus ie_error_ignotus				= 0x01;
	[sub_error ie_falsum] constatus ie_lima_nulla					= 0x02;
	[sub_error ie_falsum] constatus ie_semita_nulla					= 0x03;
	[sub_error ie_falsum] constatus ie_limae_apertae_nimium			= 0x04;
	[sub_error ie_falsum] constatus ie_permissio_nulla				= 0x05;
	[sub_error ie_falsum] constatus ie_manubrium_defectum			= 0x06;
	[sub_error ie_falsum] constatus ie_memoria_nulla				= 0x07;
	[sub_error ie_falsum] constatus ie_machinatio_defecta			= 0x08;
	[sub_error ie_falsum] constatus ie_legere_sole					= 0x09;
	[sub_error ie_falsum] constatus ie_spatium_disci_nullum			= 0x0A;
	[sub_error ie_falsum] constatus ie_lima_preexistat				= 0x0B;
	[sub_error ie_falsum] constatus ie_implantatio_nulla			= 0x0C;
	[sub_error ie_falsum] constatus ie_collectorium_vacuum_non		= 0x0D;
	[sub_error ie_falsum] constatus ie_collectorium_currens_est		= 0x0E;
	[sub_error ie_falsum] constatus ie_machinatio_idem_non			= 0x0F;
	[sub_error ie_falsum] constatus ie_nomen_semitae_defectum		= 0x10;
	[sub_error ie_falsum] constatus ie_nomen_limae_largum_nimium	= 0x11;
	[sub_error ie_falsum] constatus ie_lima_larga_nimium			= 0x12;
	[sub_error ie_falsum] constatus ie_legere_falsum				= 0x13;
	[sub_error ie_falsum] constatus ie_scribere_falsum				= 0x14;
	[sub_error ie_falsum] constatus ie_creare_falsum				= 0x15;
	[sub_error ie_falsum] constatus ie_aperire_falsum				= 0x16;

	[sub_error xe_defectus] constatus xe_error_nullus			= 0x00;
	[sub_error xe_defectus] constatus xe_modulus_nullus			= 0x01;
	[sub_error xe_defectus] constatus xe_imago_falsa			= 0x02;
	[sub_error xe_defectus] constatus xe_functio_falsa			= 0x03;
	[sub_error xe_defectus] constatus xe_abi_functionis_falsa	= 0x04;
	[sub_error xe_defectus] constatus xe_symbolus_duplicatus	= 0x05;
	[sub_error xe_defectus] constatus xe_adhaesio_defecta		= 0x06;
	[sub_error xe_defectus] constatus xe_importus_falsus		= 0x07;
	[sub_error xe_defectus] constatus xe_librarium_nullum		= 0x08;
	[sub_error xe_defectus] constatus xe_lib_importus_falsus	= 0x09;
	[sub_error xe_defectus] constatus xe_allocatus_defectus		= 0x0A;
	[sub_error xe_defectus] constatus xe_initium_defectum		= 0x0B;
	[sub_error xe_defectus] constatus xe_versio_moduli_falsa	= 0x0C;
	[sub_error xe_defectus] constatus xe_modulus_non_constitus	= 0x0D;
	[sub_error xe_defectus] constatus xe_modulus_non_fidelis	= 0x0E;
}

[[importa] inc_sec] functio nint incrementum_securum(~nint valor);
[[importa] dec_sec] functio nint decrementum_securum(~nint valor);

genus linea {
	@nihil _data;
	int longitudo { [[importa] "spu_long"] [[thiscall_nullum]] adipisce; }

	functio int initus() { responde 0; }
	functio int finis() { responde longitudo - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde longitudo; }

	constatus radix_bina		= "01";
	constatus radix_octava		= "01234567";
	constatus radix_decima		= "0123456789";
	constatus radix_sextadecima	= "0123456789ABCDEF";

	structor () { _data = nullus; }
	structor motus (~linea s) { _data = s._data; s._data = nullus; }
	destructor () { memoria.dimitte(_data); }

	[[importa] "spu_crea"]			[[thiscall_nullum]]	[[convertor] "conformis"]	structor (~linea valor) iacit;
	[[importa] "spu_crea_utf32"]	[[thiscall_nullum]]	[[convertor] "conformis"]	structor (@char valor) iacit;

	enumeratio codex {
		ignotus		= 0x00,
		ascii		= 0x01,
		utf8		= 0x02,
		utf16		= 0x03,
		utf32		= 0x04,
	}

	[[importa] "spu_crea_int8"]		[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (int8 valor) iacit;
	[[importa] "spu_crea_nint8"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (nint8 valor) iacit;
	[[importa] "spu_crea_int16"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (int16 valor) iacit;
	[[importa] "spu_crea_nint16"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (nint16 valor) iacit;
	[[importa] "spu_crea_int32"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (int32 valor) iacit;
	[[importa] "spu_crea_nint32"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (nint32 valor) iacit;
	[[importa] "spu_crea_int64"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (int64 valor) iacit;
	[[importa] "spu_crea_nint64"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (nint64 valor) iacit;
	[[importa] "spu_crea_intadl"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (intadl valor) iacit;
	[[importa] "spu_crea_nintadl"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (nintadl valor) iacit;
	[[importa] "spu_crea_frac32"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (frac valor) iacit;
	[[importa] "spu_crea_frac64"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (dfrac valor) iacit;
	[[importa] "spu_crea_logicum"]	[[thiscall_nullum]]	[[convertor] "extendens:pretiosus"] structor (logicum valor) iacit;
	[[importa] "spu_crea_char"]		[[thiscall_nullum]] structor (char valor, int long) iacit;
	[[importa] "spu_crea_adl"]		[[thiscall_nullum]] structor (@nihil valor) iacit;
	[[importa] "spu_crea_data"]		[[thiscall_nullum]] structor (@nihil valor, int long, codex cdx) iacit;
	[[importa] "spu_loca"]			[[thiscall_nullum]] functio ~linea operator = (~linea valor) iacit;
	[[importa] "spu_loca_utf32"]	[[thiscall_nullum]] functio ~linea operator = (@char valor) iacit;
	[[importa] "spu_concat"]		[[thiscall_nullum]] functio ~linea operator += (~linea valor) iacit;
	[[importa] "spu_index"]			[[thiscall_nullum]] functio char operator [] (int index);

	[[importa] "spu_crea_nint32_radix"]		[[thiscall_nullum]] structor (nint32 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nint64_radix"]		[[thiscall_nullum]] structor (nint64 valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_nintadl_radix"]	[[thiscall_nullum]] structor (nintadl valor, ~linea radix, int long_min) iacit;
	[[importa] "spu_crea_frac32_2"]			[[thiscall_nullum]] structor (frac valor, char punctum) iacit;
	[[importa] "spu_crea_frac32_3"]			[[thiscall_nullum]] structor (frac valor, char punctum, int long) iacit;
	[[importa] "spu_crea_frac64_2"]			[[thiscall_nullum]] structor (dfrac valor, char punctum) iacit;
	[[importa] "spu_crea_frac64_3"]			[[thiscall_nullum]] structor (dfrac valor, char punctum, int long) iacit;

	[[importa] "spu_concat_classis"]	classis functio linea operator + (~linea a, ~linea b) iacit;
	[[importa] "spu_compareo"]			classis functio int operator <=> (~linea a, ~linea b);
	[[importa] "spu_compareo_2"]		classis functio int operator # (~linea a, ~linea b);

	classis functio logicum operator == (~linea a, ~linea b) { responde a <=> b == 0; }
	classis functio logicum operator != (~linea a, ~linea b) { responde a <=> b != 0; }
	classis functio logicum operator <= (~linea a, ~linea b) { responde a <=> b <= 0; }
	classis functio logicum operator >= (~linea a, ~linea b) { responde a <=> b >= 0; }
	classis functio logicum operator < (~linea a, ~linea b) { responde a <=> b < 0; }
	classis functio logicum operator > (~linea a, ~linea b) { responde a <=> b > 0; }

	[[importa] "spu_reperi_primus"]		[[thiscall_nullum]] functio int reperi_primum(~linea valor);
	[[importa] "spu_reperi_ultimus"]	[[thiscall_nullum]] functio int reperi_ultimum(~linea valor);
	[[importa] "spu_fragmentum"]		[[thiscall_nullum]] functio linea fragmentum(int primus, int long) iacit;
	[[importa] "spu_surroga"]			[[thiscall_nullum]] functio linea surroga(~linea sublinea, ~linea cum) iacit;
	[[importa] "spu_codex_long"]		[[thiscall_nullum]] functio int longitudo_codicis(codex cdx) iacit;
	[[importa] "spu_codifica"]			[[thiscall_nullum]] functio nihil codifica(@nihil data, codex cdx, logicum termina) iacit;
	
	[[importa] "spu_ad_int32"]			[[thiscall_nullum]] functio int32 ad_int32() iacit;
	[[importa] "spu_ad_int32_2"]		[[thiscall_nullum]] functio int32 ad_int32(~linea radix) iacit;
	[[importa] "spu_ad_int32_3"]		[[thiscall_nullum]] functio int32 ad_int32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint32"]			[[thiscall_nullum]] functio nint32 ad_nint32() iacit;
	[[importa] "spu_ad_nint32_2"]		[[thiscall_nullum]] functio nint32 ad_nint32(~linea radix) iacit;
	[[importa] "spu_ad_nint32_3"]		[[thiscall_nullum]] functio nint32 ad_nint32(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_int64"]			[[thiscall_nullum]] functio int64 ad_int64() iacit;
	[[importa] "spu_ad_int64_2"]		[[thiscall_nullum]] functio int64 ad_int64(~linea radix) iacit;
	[[importa] "spu_ad_int64_3"]		[[thiscall_nullum]] functio int64 ad_int64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_nint64"]			[[thiscall_nullum]] functio nint64 ad_nint64() iacit;
	[[importa] "spu_ad_nint64_2"]		[[thiscall_nullum]] functio nint64 ad_nint64(~linea radix) iacit;
	[[importa] "spu_ad_nint64_3"]		[[thiscall_nullum]] functio nint64 ad_nint64(~linea radix, logicum sensitivus) iacit;
	[[importa] "spu_ad_frac32"]			[[thiscall_nullum]] functio frac ad_frac() iacit;
	[[importa] "spu_ad_frac32_2"]		[[thiscall_nullum]] functio frac ad_frac(~linea punctum) iacit;
	[[importa] "spu_ad_frac64"]			[[thiscall_nullum]] functio dfrac ad_dfrac() iacit;
	[[importa] "spu_ad_frac64_2"]		[[thiscall_nullum]] functio dfrac ad_dfrac(~linea punctum) iacit;

	[[importa] "spu_forma_0"] classis functio linea forma(~linea schema, ~linea a0) iacit;
	[[importa] "spu_forma_1"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1) iacit;
	[[importa] "spu_forma_2"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2) iacit;
	[[importa] "spu_forma_3"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3) iacit;
	[[importa] "spu_forma_4"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4) iacit;
	[[importa] "spu_forma_5"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5) iacit;
	[[importa] "spu_forma_6"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6) iacit;
	[[importa] "spu_forma_7"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7) iacit;
	[[importa] "spu_forma_8"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8) iacit;
	[[importa] "spu_forma_9"] classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8, ~linea a9) iacit;

	linea inferna	{ [[importa] "spu_inferna"]	[[thiscall_nullum]] adipisce iacit; }
	linea supera	{ [[importa] "spu_supera"]	[[thiscall_nullum]] adipisce iacit; }
}
genus linea_secura hereditat linea {
	structor () {}
	structor (~linea_secura valor) { _data = valor._data; valor._data = nullus; }
	[[thiscall_nullum]] [[importa] spu_crea_sec] structor (~linea valor);
}

spatium errores {
	[[importa] descriptio_erroris] functio nihil _descriptio_erroris(nintadl ec, nintadl esc, @nihil mdl, ~linea error, ~linea sub_error);
	functio nihil descriptio(nintadl ec, nintadl esc, ~linea error, ~linea sub_error) { _descriptio_erroris(ec, esc, modulus(), error, sub_error); }
}
spatium actuarius {
	protocollum _actuarius { functio nihil scribe(~linea ln) virtualis pura; }
	functio nihil scribe(~linea ln) { (@_actuarius)(protocollum(actuarius))^.scribe(ln); }
}
spatium systema {
	enumeratio architectura {
		ignota	= 0x00,
		i386	= 0x01,
		x64		= 0x11,
		arm_m32	= 0x02,
		arm_a64	= 0x12
	}
	enumeratio operans {
		ignota	= 0x00,
		windows	= 0x01,
		macos	= 0x02,
		linux	= 0x03
	}

	structura informatio {
		int64 frequentia_processoris;
		int64 numerus_memoriae;
		linea nomen_processoris;
		operans systema_machinae;
		architectura architectura_machinae;
		architectura architectura_processi;
		int32 numerus_cordium_corporalium;
		int32 numerus_cordium_virtualium;
		int32 versio_systemae_supera;
		int32 versio_systemae_inferna;
	}

	[[importa] sys_info]	functio nihil para_informationem(~informatio inf);
	[[importa] sys_temp]	functio nint32 para_tempum_systemae();
	[[importa] sys_arch]	functio logicum proba_architecturam(architectura arch);
}
enumeratio tactus {
	back		= 0x08,
	tab			= 0x09,
	enter		= 0x0D,
	shift		= 0x10,
	ctrl		= 0x11,
	alt			= 0x12,
	system		= 0xFFFF,
	pause		= 0x13,
	caps_lock	= 0x14,
	escape		= 0x1B,
	l_shift		= 0xA0,
	r_shift		= 0xA1,
	l_ctrl		= 0xA2,
	r_ctrl		= 0xA3,
	l_alt		= 0xA4,
	r_alt		= 0xA5,
	l_system	= 0x5B,
	r_system	= 0x5C,
	space		= ' ',
	page_up		= 0x21,
	page_down	= 0x22,
	end			= 0x23,
	home		= 0x24,
	left		= 0x25,
	up			= 0x26,
	right		= 0x27,
	down		= 0x28,
	select		= 0x29,
	print		= 0x2A,
	execute		= 0x2B,
	prnt_scrn	= 0x2C,
	insert		= 0x2D,
	delete		= 0x2E,
	help		= 0x2F,
	N0			= '0',
	N1			= '1',
	N2			= '2',
	N3			= '3',
	N4			= '4',
	N5			= '5',
	N6			= '6',
	N7			= '7',
	N8			= '8',
	N9			= '9',
	A			= 'A',
	B			= 'B',
	C			= 'C',
	D			= 'D',
	E			= 'E',
	F			= 'F',
	G			= 'G',
	H			= 'H',
	I			= 'I',
	J			= 'J',
	K			= 'K',
	L			= 'L',
	M			= 'M',
	N			= 'N',
	O			= 'O',
	P			= 'P',
	Q			= 'Q',
	R			= 'R',
	S			= 'S',
	T			= 'T',
	U			= 'U',
	V			= 'V',
	W			= 'W',
	X			= 'X',
	Y			= 'Y',
	Z			= 'Z',
	sleep		= 0x5F,
	NP0			= 0x60,
	NP1			= 0x61,
	NP2			= 0x62,
	NP3			= 0x63,
	NP4			= 0x64,
	NP5			= 0x65,
	NP6			= 0x66,
	NP7			= 0x67,
	NP8			= 0x68,
	NP9			= 0x69,
	multiply	= 0x6A,
	add			= 0x6B,
	separator	= 0x6C,
	subtract	= 0x6D,
	decimal		= 0x6E,
	divide		= 0x6F,
	F1			= 0x70,
	F2			= 0x71,
	F3			= 0x72,
	F4			= 0x73,
	F5			= 0x74,
	F6			= 0x75,
	F7			= 0x76,
	F8			= 0x77,
	F9			= 0x78,
	F10			= 0x79,
	F11			= 0x7A,
	F12			= 0x7B,
	F13			= 0x7C,
	F14			= 0x7D,
	F15			= 0x7E,
	F16			= 0x7F,
	F17			= 0x80,
	F18			= 0x81,
	F19			= 0x82,
	F20			= 0x83,
	F21			= 0x84,
	F22			= 0x85,
	F23			= 0x86,
	F24			= 0x87,
	num_lock	= 0x90,
	scrl_lock	= 0x91,
	oem_plus	= 0xBB,
	oem_comma	= 0xBC,
	oem_minus	= 0xBD,
	oem_prd		= 0xBE,
	oem_clear	= 0xFE,
	vol_mute	= 0xAD,
	vol_down	= 0xAE,
	vol_up		= 0xAF,
	OEM1		= 0xBA,
	OEM2		= 0xBF,
	OEM3		= 0xC0,
	OEM4		= 0xDB,
	OEM5		= 0xDC,
	OEM6		= 0xDD,
	OEM7		= 0xDE,
	OEM8		= 0xFF,
}

[[magnitudo] "0:2"] genus virtualis objectum {
	[[positus] "0:1"] nint _num_ref;

	structor () { funda _num_ref(1); }
	functio nint contine() virtualis { responde incrementum_securum(_num_ref); }
	functio nint dimitte() virtualis { var nr = decrementum_securum(_num_ref); si (nr == nint(0)) perde ego; responde nr; }
	destructor () virtualis {}
	functio nihil _perde() virtualis { perde ego; }
	functio linea_secura ad_lineam() virtualis { proba { responde linea("objectum"); } responde linea_secura(); }
}
genus objectum_dynamicum hereditat objectum {
	structor () {}
	functio @nihil converte_dynamice(@nihil gen) iacit virtualis pura;
	functio @nihil para_classem() virtualis pura;
}
protocollum dynamicum {
	functio @nihil converte_dynamice(@nihil gen) iacit virtualis pura;
	functio @nihil para_classem() virtualis pura;
}

praeforma functio permuta(T) { \cense T genus(_0)\ functio nihil $_(~$T t1, ~$T t2) {
	ordo [magnitudo_maxima($T)] nint8 m;
	memoria.exscribe(@m, @t1, magnitudo(t1));
	memoria.exscribe(@t1, @t2, magnitudo(t1));
	memoria.exscribe(@t2, @m, magnitudo(t1));
} }
praeforma genus dordo(V) { genus $_ hereditat objectum {
	@$V _data;
	int _numerus;
	int _allocatus;
	int _talea;
	nomen_alternum genus_objectum = $V;

	functio int _poli(int num) { responde ((num + _talea - 1) / _talea) * _talea; }
	functio nihil _adde(~$V v) iacit { initia(@_data[_numerus], v); _numerus++; }
	functio nihil _realloca(int num) iacit
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _allocatus) {
			si (numerus_novus > _allocatus) {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; } alioqui iace errores.memoria_nulla;
			} alioqui {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
			}
		}
	}
	functio nihil _realloca_secura(int num)
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _numerus) {
			var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
			si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
		}
	}

	structor () { funda _numerus(0); funda _allocatus(0); funda _talea(0x100); _data = nullus; }
	structor (~dordo[$V] valor) iacit
	{
		funda _numerus(valor._numerus);
		funda _allocatus(0);
		funda _talea(valor._talea);
		_data = nullus;
		_realloca(_numerus);
		int i = 0;
		proba { per (i = 0; i < _numerus; i++) initia(@_data[i], valor._data[i]); } cape (intadl e, intadl se) {
			per (int j = i - 1; j >= 0; j--) fini(_data[i]);
			memoria.dimitte(_data);
			iace e, se;
		}
	}
	structor (int talea) { funda _numerus(0); funda _allocatus(0); funda _talea(talea); _data = nullus; }
	destructor() redefini { per (int i = 0; i < _numerus; i++) fini(_data[i]); memoria.dimitte(_data); }

	functio ~dordo[$V] operator = (~dordo[$V] valor) iacit
	{
		si (ego == @valor) responde ego^;
		dordo[$V] copia(valor);
		per (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = copia._data;
		_numerus = copia._numerus;
		_allocatus = copia._allocatus;
		_talea = copia._talea;
		copia._data = nullus;
		copia._numerus = copia._allocatus = 0;
		responde ego^;
	}
	functio ~$V operator [] (int i) { responde _data[i]; }
	convertor (@$V) () { responde _data; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~$V v) iacit { o.adde(v); responde o; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~dordo[$V] o2) iacit { o.adde(o2); responde o; }

	functio nihil adde(~$V v) iacit { _realloca(_numerus + 1); _adde(v); }
	functio nihil adde(~dordo[$V] o) iacit
	{
		si (ego == @o) iace errores.argumentum_falsum;
		_realloca(_numerus + o._numerus);
		per (int i = 0; i < o._numerus; i++) _adde(o._data[i]);
	}
	functio nihil adde(@$V v, int numerus) iacit
	{
		si (!numerus) responde;
		si (v == _data) iace errores.argumentum_falsum;
		_realloca(_numerus + numerus);
		per (int i = 0; i < numerus; i++) _adde(v[i]);
	}
	functio nihil permuta(int i, int j) { .permuta(_data[i], _data[j]); }
	functio nihil insere(~$V v, int pos) iacit
	{
		_realloca(_numerus + 1);
		per (int i = _numerus - 1; i >= pos; i--) .permuta(_data[i], _data[i + 1]);
		proba { initia(@_data[pos], v); _numerus++; }
		cape (intadl e, intadl se) { per (int i = pos; i < _numerus; i++) .permuta(_data[i], _data[i + 1]); iace e, se; }
	}
	functio nihil remove(int pos)
	{
		fini _data[pos];
		per (int i = pos; i < _numerus - 1; i++) .permuta(_data[i], _data[i + 1]);
		_numerus--; _realloca_secura(_numerus);
	}
	functio nihil remove_primum() { remove(0); }
	functio nihil remove_ultimum() { remove(_numerus - 1); }
	functio nihil depura()
	{
		per (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = nullus;
		_numerus = _allocatus = 0;
	}
	functio ~$V primus() { responde _data[0]; }
	functio ~$V ultimus() { responde _data[_numerus - 1]; }

	functio linea_secura ad_lineam() redefini
	{
		proba {
			linea resp = "ordo : [";
			per (int i = 0; i < _numerus; i++) {
				si (i) resp += ", ";
				resp += linea.ex(_data[i]);
			}
			responde resp + "]";
		}
		responde linea_secura();
	}

	int longitudo {
		adipisce { responde _numerus; }
		\si tractus.habet_structor($V)\ loca iacit {
			si (valor > _numerus) {
				_realloca(valor); int i;
				proba { per (i = _numerus; i < valor; i++) initia(@_data[i]); }
				cape (intadl e, intadl se) { per (int j = i - 1; j >= _numerus; j--) fini _data[j]; iace e, se; }
				_numerus = valor;
			} alioqui si (valor < _numerus) {
				si (valor < 0) iace errores.argumentum_falsum;
				per (int i = valor; i < _numerus; i++) fini _data[i];
				_numerus = valor; _realloca_secura(valor);
			}
		} \fini\
	}
	@$V data { adipisce { responde _data; } }

	functio int initus() { responde 0; }
	functio int finis() { responde _numerus - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde _numerus; }
} }
praeforma genus adl(O) { genus $_ {
	@$O _adl;
	nomen_alternum genus_objectum = $O;
	structor () { _adl = nullus; }
	structor (@$O o) { _adl = o; }
	structor (~adl[$O] o) { _adl = o._adl; si(_adl != nullus) _adl^.contine(); }
	destructor () { si(_adl != nullus) _adl^.dimitte(); }
	functio ~$O operator ^ () { responde _adl^; }
	functio logicum operator ! () { responde _adl == nullus; }
	functio ~adl[$O] operator = (~adl[$O] valor)
	{
		si (ego == @valor) responde ego^;
		si (_adl != nullus) _adl^.dimitte();
		_adl = valor._adl;
		si (_adl != nullus) _adl^.contine();
		responde ego^;
	}
	convertor (@$O) () { responde _adl; }
	convertor (logicum) () { responde _adl != nullus; }
	functio @$O valor() { responde _adl; }
	functio @@$O valor_adl() { responde @_adl; }
	functio nihil depura() { si (_adl != nullus) _adl^.dimitte(); _adl = nullus; }
	functio nihil contine(@$O o) { si (_adl != nullus) _adl^.dimitte(); _adl = o; si (_adl != nullus) _adl^.contine(); }
	functio linea_secura ad_lineam()
	{
		proba {
			si (_adl == nullus) responde linea("nullus");
			alioqui responde _adl^.ad_lineam();
		}
		responde linea_secura();
	}
	classis functio logicum operator == (~adl[$O] a, ~adl[$O] b) { responde a._adl == b._adl; }
	classis functio logicum operator != (~adl[$O] a, ~adl[$O] b) { responde a._adl != b._adl; }
	classis functio logicum operator == (~adl[$O] a, @$O b) { responde a._adl == b; }
	classis functio logicum operator != (~adl[$O] a, @$O b) { responde a._adl != b; }
	classis functio logicum operator == (@$O a, ~adl[$O] b) { responde a == b._adl; }
	classis functio logicum operator != (@$O a, ~adl[$O] b) { responde a != b._adl; }
} }
praeforma genus duplex(A, B) { structura $_ {
	$A primus;
	$B secundus;
	structor (~$A a, ~$B b) iacit { funda primus(a); funda secundus(b); }
} }
praeforma genus triplex(A, B, C) { structura $_ {
	$A primus;
	$B secundus;
	$C tertius;
	structor (~$A a, ~$B b, ~$C c) iacit { funda primus(a); funda secundus(b); funda tertius(c); }
} }
praeforma genus quadriplex(A, B, C, D) { structura $_ {
	$A primus;
	$B secundus;
	$C tertius;
	$D quartus;
	structor (~$A a, ~$B b, ~$C c, ~$D d) iacit { funda primus(a); funda secundus(b); funda tertius(c); funda quartus(d); }
} }

nomen_alternum dordo_linearum = dordo[linea];
nomen_alternum dordo_datorum = dordo[nint8];

dura linea {
	[[importa] "spu_codifica_taleam"]	[[thiscall_nullum]] functio adl[dordo_datorum] codifica(codex cdx, logicum termina) iacit;
	[[importa] "spu_scinde"]			[[thiscall_nullum]] functio adl[dordo_linearum] scinde(char) iacit;

	praeforma functio ex(T) { \cense T genus(_0)\ functio linea $_(~$T t) iacit {
		\si tractus.convertitur($T, linea)\
			responde linea(t);
		\fini\
		\si !tractus.convertitur($T, linea)\
			\si tractus.habet($T, "ad_lineam")\
				\si tractus.habet_vers($T.ad_lineam)\
					responde t.ad_lineam();
				\fini\
				\si !tractus.habet_vers($T.ad_lineam)\
					responde "?";
				\fini\
			\fini\
			\si !tractus.habet($T, "ad_lineam")\
				\si tractus.est_cls($T)\
					linea r = "structura " + tractus.nomen($T) + " : [\n";
					\replica F $T\
						r += linea(tractus.nomen($T.\loca F\)) + " = " + linea.ex(t.\loca F\) + "\n";
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_ordo($T)\
					linea r = "ordo : [";
					\replica N $T\
						si (\loca N\) r += ", ";
						r += linea.ex(t[\loca N\]);
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_adl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_fadl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_com($T)\
					responde linea((@nihil)(@t));
				\fini\
				responde "?";
			\fini\
		\fini\
	} }
}

[[significatio] integer] genus tempus {
	nint64 momentum;

	structor () {}
	structor (tempus valor) { funda momentum(valor.momentum); }
	structor (nint64 valor) { funda momentum(valor); }
	[[thiscall_nullum]] [[importa] tmp_crea_7] structor (int annus, int mensis, int dies, int hora, int minuta, int secunda, int millisecunda);
	[[thiscall_nullum]] [[importa] tmp_crea_4] structor (int hora, int minuta, int secunda, int millisecunda);

	classis functio logicum operator == (tempus a, tempus b) { responde a.momentum == b.momentum; }
	classis functio logicum operator != (tempus a, tempus b) { responde a.momentum != b.momentum; }
	classis functio logicum operator <= (tempus a, tempus b) { responde a.momentum <= b.momentum; }
	classis functio logicum operator >= (tempus a, tempus b) { responde a.momentum >= b.momentum; }
	classis functio logicum operator < (tempus a, tempus b) { responde a.momentum < b.momentum; }
	classis functio logicum operator > (tempus a, tempus b) { responde a.momentum > b.momentum; }

	classis functio tempus operator + (tempus a, tempus b) { responde a.momentum + b.momentum; }
	classis functio tempus operator - (tempus a, tempus b) { responde a.momentum - b.momentum; }

	convertor (nint64) () { responde momentum; }
	functio ~tempus operator = (tempus t) { momentum = t.momentum; responde ego^; }
	functio ~tempus operator += (tempus t) { momentum += t.momentum; responde ego^; }
	functio ~tempus operator -= (tempus t) { momentum -= t.momentum; responde ego^; }

	int annus { [[thiscall_nullum]] [[importa] tmp_a_ans] adipisce; }
	int mensis { [[thiscall_nullum]] [[importa] tmp_a_mns] adipisce; }
	int dies_septimanae { [[thiscall_nullum]] [[importa] tmp_a_dis] adipisce; }
	int dies { [[thiscall_nullum]] [[importa] tmp_a_die] adipisce; }
	int hora { [[thiscall_nullum]] [[importa] tmp_a_hor] adipisce; }
	int minuta { [[thiscall_nullum]] [[importa] tmp_a_min] adipisce; }
	int secunda { [[thiscall_nullum]] [[importa] tmp_a_sec] adipisce; }
	int millisecunda { [[thiscall_nullum]] [[importa] tmp_a_msc] adipisce; }

	tempus tempus_universalus { [[thiscall_nullum]] [[importa] tmp_a_uni] adipisce; }
	tempus tempus_localis { [[thiscall_nullum]] [[importa] tmp_a_loc] adipisce; }

	[[thiscall_nullum]] [[importa] tmp_adl] functio linea ad_lineam() iacit;
	[[thiscall_nullum]] [[importa] tmp_alb] functio linea ad_lineam_brevem() iacit;

	[[importa] tmp_cur] classis functio tempus currens();
	[[thiscall_nullum]] [[importa] tmp_dim] functio int dies_in_mense();
}

genus flumen hereditat objectum {
	constatus initus	= 0;
	constatus currens	= 1;
	constatus finis		= 2;

	structor () {}
	functio int lege(@nihil data, int long) iacit virtualis pura;
	functio nihil scribe(@nihil data, int long) iacit virtualis pura;
	functio int64 quaerita(int64 pos, int origo) iacit virtualis pura;
	int64 longitudo {
		adipisce iacit virtualis pura;
		loca iacit virtualis pura;
	}
	functio nihil annoda() virtualis pura;
	functio logicum _est_xv() virtualis { responde sic; }

	[[thiscall_nullum]] [[importa] flumen_ex_2] functio nihil exscribe(@flumen in, int64 long) iacit;
	[[thiscall_nullum]] [[importa] flumen_ex_1] functio nihil exscribe(@flumen in) iacit;
	[[thiscall_nullum]] [[importa] flumen_lo_1] functio adl[dordo_datorum] lege_ordinem(int long) iacit;
	[[thiscall_nullum]] [[importa] flumen_lo_0] functio adl[dordo_datorum] lege_ordinem() iacit;
	[[thiscall_nullum]] [[importa] flumen_so_1] functio nihil scribe_ordinem(@dordo_datorum ord) iacit;
}

[[importa] flumen_mem_0] functio adl[flumen] crea_flumenem_in_memoria() iacit;
[[importa] flumen_mem_2] functio adl[flumen] crea_flumenem_in_memoria(@nihil data, intadl long) iacit;
[[importa] flumen_auxil] functio adl[flumen] para_auxilium(@nihil mod, ~linea aux_genus, int aux_num) iacit;

spatium scriptio {
	constatus character_finis = 0xFFFFFFFF;
	genus codificator hereditat objectum {
		structor () {}
		functio nihil scribe(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam() iacit virtualis pura;
		functio nihil scribe_subscriptionem() iacit virtualis pura;

		classis functio ~codificator operator << (~codificator cdf, ~linea ln) iacit { cdf.scribe(ln); responde cdf; }
	}
	genus decodificator hereditat objectum {
		structor () {}
		functio char lege_characterem() iacit virtualis pura;
		functio linea lege_lineam() iacit virtualis pura;
		functio linea lege_cunctos() iacit virtualis pura;

		logicum finis { adipisce virtualis pura; }
		linea.codex codex { adipisce virtualis pura; }

		classis functio ~decodificator operator >> (~decodificator cdf, ~linea ln) iacit { ln = cdf.lege_lineam(); responde cdf; }
	}

	[[importa] scr_cod_1] functio adl[codificator] codifica(@flumen fl) iacit;
	[[importa] scr_cod_2] functio adl[codificator] codifica(@flumen fl, linea.codex codex) iacit;
	[[importa] scr_dec_1] functio adl[decodificator] decodifica(@flumen fl) iacit;
	[[importa] scr_dec_2] functio adl[decodificator] decodifica(@flumen fl, linea.codex codex) iacit;
}
spatium contextus {
	genus semaphorum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil aperi() virtualis pura;
	}
	genus signale hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil erige() virtualis pura;
		functio nihil inclina() virtualis pura;
	}
	genus labos hereditat objectum {
		structor () {}
		functio nihil exeque(@objectum ctx) virtualis pura;
	}
	genus labos_opperitus hereditat labos {
		adl[signale] valor_publicus_signale_opperirendi;
		structor () iacit { valor_publicus_signale_opperirendi = crea_signale(); si (!valor_publicus_signale_opperirendi) iace errores.memoria_nulla; }
		functio nihil exeque(@objectum ctx) redefini {}
	}
	genus filum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		logicum activum { adipisce virtualis pura; }
		int numerus_exitus { adipisce virtualis pura; }
	}
	genus cauda hereditat objectum {
		structor () {}
		functio logicum adde(@labos lab) virtualis pura;
		functio logicum adde(@@labos lab, int num) virtualis pura;
	}
	genus cauda_simplex hereditat cauda {
		structor () {}
		functio nihil exeque() virtualis pura;
		functio logicum exeque_semel() virtualis pura;
		functio adl[filum] exeque_in_filo() virtualis pura;
		functio nihil siste() virtualis pura;
		functio nihil linque() virtualis pura;
		int longitudo { adipisce virtualis pura; }
	}
	genus cauda_filorum hereditat cauda {
		structor () {}
		functio nihil para_statum(~int num_fil, ~int num_act_fil, ~int num_lab) virtualis pura;
		functio nihil opperire() virtualis pura;
	}

	[[importa] ctx_dormi] functio nihil dormi(nint ms);
	[[importa] ctx_siste] functio nihil siste(nint valor);

	[[importa] ctx_ccsim] functio adl[cauda_simplex] crea_caudam_simplicem();
	[[importa] ctx_ccfl0] functio adl[cauda_filorum] crea_caudam_filorum();
	[[importa] ctx_ccfl1] functio adl[cauda_filorum] crea_caudam_filorum(int num);
	[[importa] ctx_crsem] functio adl[semaphorum] crea_semaphorum(int valor);
	[[importa] ctx_crsgn] functio adl[signale] crea_signale();
	[[importa] ctx_crfil] functio adl[filum] exeque(@labos lab);

	functio nihil exeque_in_contextu(@cauda ctx, @labos lab) { ctx^.adde(lab); }
	functio adl[signale] exeque_in_contextu_et_opperire(@cauda ctx, @labos_opperitus lab) { ctx^.adde(lab); responde lab^.valor_publicus_signale_opperirendi; }

	[[importa] alloca_in_filo]	functio logicum crea_data_fili(~nintadl nomen);
	[[importa] dimitte_in_filo]	functio nihil perde_data_fili(nintadl nomen);
	[[importa] scribe_in_filo]	functio	nihil scribe_data_fili(nintadl nomen, nintadl valor);
	[[importa] lege_in_filo]	functio nintadl lege_data_fili(nintadl nomen);
}

praeforma operator muta_contextum(C) { .contextus.exeque_in_contextu($C, .contextus.labos ## { $_ }) }
praeforma operator muta_contextum_et_opperire(C) { .contextus.exeque_in_contextu_et_opperire($C, .contextus.labos_opperitus ## { $_ }) }

genus meta hereditat objectum {
	constatus attributum_nomen_moduli	= "NomenModuli";
	constatus attributum_creator_moduli	= "CreatorModuli";
	constatus attributum_iura_exempli	= "IuraExempli";
	constatus attributum_versio			= "Versio";

	structor() {}

	functio int initus() virtualis pura;
	functio int finis() virtualis pura;
	functio int prae_initus() virtualis pura;
	functio int post_finis() virtualis pura;

	functio linea operator [] (int num) iacit virtualis pura;
	functio linea operator [] (~linea attr) iacit virtualis pura;

	[[importa] meta_moduli] classis functio adl[meta] moduli(@nihil mdl) iacit;
}