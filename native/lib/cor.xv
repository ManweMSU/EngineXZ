auxilium attributum ("NomenModuli") = "Liber Cordis";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2024";
auxilium attributum ("Versio") = "1.0.0.1";

[[systema] libera]

[[innatum]] [[magnitudo] "0"] [[significatio] nihil]
genus nihil {}

[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus logicum {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (logicum src) {
		INTERFACE W 1 : THIS 1 => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio logicum operator - () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ~ () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOT:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~logicum operator = (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator |= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator &= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~logicum operator #= (logicum src) {
		INTERFACE W 1 : THIS 1 => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio logicum operator | (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator & (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator # (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @SAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTSAME:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (logicum a, logicum b) {
		INTERFACE 1 1 => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer_signus]
genus int8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio int8 operator - () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio int8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~int8 operator = (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator += (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator *= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator /= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator %= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @S_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator |= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator &= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator #= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator <<= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator >>= (int8 src) {
		INTERFACE W 1 : THIS 1 : SINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SAR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int8 operator + (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator - (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator * (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator / (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator % (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator | (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator & (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator # (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator << (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio int8 operator >> (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @SAR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int8 a, int8 b) {
		INTERFACE 1 : SINT 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "1"] [[significatio] integer]
genus nint8 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => 0
		CODE { RET { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } }
	}
	[[xa]] functio nint8 operator - () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @NEG:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio nint8 operator ~ () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @INVERSE:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] functio ~nint8 operator = (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator += (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator *= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MUL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator /= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_DIV:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator %= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @U_MOD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator |= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @OR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator &= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @AND:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator #= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @XOR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator <<= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHL:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator >>= (nint8 src) {
		INTERFACE W 1 : THIS 1 : UINT => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SHR:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @ADD:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint8 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), @SUB:1 1=>1(@PTR_FOLLOW:W 1=>1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint8 operator + (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @ADD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator - (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SUB:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator * (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MUL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator / (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_DIV:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator % (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_MOD:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator | (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @OR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator & (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @AND:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator # (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @XOR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator << (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHL:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio nint8 operator >> (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @SHR:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:1 1=>1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint8 a, nint8 b) {
		INTERFACE 1 : UINT 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:1 1=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer_signus]
genus int16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio int16 operator - () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio int16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~int16 operator = (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator += (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator *= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator /= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator %= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @S_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator |= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator &= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator #= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator <<= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator >>= (int16 src) {
		INTERFACE W 1 : THIS 2 : SINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SAR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int16 operator + (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator - (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator * (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator / (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator % (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator | (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator & (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator # (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator << (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio int16 operator >> (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @SAR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int16 a, int16 b) {
		INTERFACE 2 : SINT 2 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "2"] [[significatio] integer]
genus nint16 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => 0
		CODE { RET { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } }
	}
	[[xa]] functio nint16 operator - () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @NEG:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio nint16 operator ~ () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @INVERSE:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] functio ~nint16 operator = (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator += (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator *= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MUL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator /= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_DIV:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator %= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @U_MOD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator |= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @OR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator &= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @AND:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator #= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @XOR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator <<= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHL:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator >>= (nint16 src) {
		INTERFACE W 1 : THIS 2 : UINT => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SHR:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @ADD:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint16 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), @SUB:2 2=>2(@PTR_FOLLOW:W 1=>2(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint16 operator + (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @ADD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator - (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SUB:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator * (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MUL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator / (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_DIV:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator % (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_MOD:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator | (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @OR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator & (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @AND:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator # (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @XOR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator << (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHL:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio nint16 operator >> (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @SHR:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:2 2=>2(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint16 a, nint16 b) {
		INTERFACE 2 : UINT 2 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:2 2=>2(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer_signus]
genus int32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio int32 operator - () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio int32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~int32 operator = (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator += (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator *= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator /= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator %= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @S_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator |= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator &= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator #= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator <<= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator >>= (int32 src) {
		INTERFACE W 1 : THIS 4 : SINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SAR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int32 operator + (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator - (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator * (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator / (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator % (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator | (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator & (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator # (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator << (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio int32 operator >> (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @SAR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int32 a, int32 b) {
		INTERFACE 4 : SINT 4 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] integer]
genus nint32 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] functio nint32 operator - () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @NEG:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio nint32 operator ~ () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @INVERSE:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] functio ~nint32 operator = (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator += (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator *= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MUL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator /= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_DIV:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator %= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @U_MOD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator |= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @OR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator &= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @AND:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator #= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @XOR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator <<= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHL:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator >>= (nint32 src) {
		INTERFACE W 1 : THIS 4 : UINT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SHR:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @ADD:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint32 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @SUB:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint32 operator + (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @ADD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator - (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SUB:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator * (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MUL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator / (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_DIV:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator % (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_MOD:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator | (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @OR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator & (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @AND:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator # (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @XOR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator << (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHL:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio nint32 operator >> (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @SHR:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint32 a, nint32 b) {
		INTERFACE 4 : UINT 4 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:4 4=>4(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer_signus]
genus int64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio int64 operator - () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio int64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~int64 operator = (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator += (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator *= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator /= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator %= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @S_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator |= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator &= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator #= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator <<= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator >>= (int64 src) {
		INTERFACE W 1 : THIS 8 : SINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SAR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~int64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio int64 operator + (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator - (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator * (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator / (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator % (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator | (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator & (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator # (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator << (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio int64 operator >> (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @SAR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (int64 a, int64 b) {
		INTERFACE 8 : SINT 8 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] integer]
genus nint64 {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] functio nint64 operator - () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @NEG:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio nint64 operator ~ () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @INVERSE:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] functio ~nint64 operator = (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator += (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator *= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MUL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator /= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_DIV:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator %= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @U_MOD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator |= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @OR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator &= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @AND:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator #= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @XOR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator <<= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHL:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator >>= (nint64 src) {
		INTERFACE W 1 : THIS 8 : UINT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SHR:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @ADD:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nint64 operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @SUB:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nint64 operator + (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @ADD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator - (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SUB:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator * (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MUL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator / (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_DIV:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator % (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_MOD:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator | (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @OR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator & (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @AND:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator # (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @XOR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator << (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHL:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio nint64 operator >> (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @SHR:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nint64 a, nint64 b) {
		INTERFACE 8 : UINT 8 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:8 8=>8(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer_signus]
genus intadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio intadl operator - () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio intadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~intadl operator = (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator += (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator *= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator /= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator %= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @S_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator |= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator &= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator #= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator <<= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator >>= (intadl src) {
		INTERFACE W 1 : THIS W 1 : SINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SAR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~intadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio intadl operator + (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator - (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator * (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator / (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator % (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator | (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator & (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator # (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator << (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio intadl operator >> (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SAR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (intadl a, intadl b) {
		INTERFACE W 1 : SINT W 1 : SINT => 1
		CODE { RET { @BLT:1 1=>1(R, @S_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "0:1"] [[significatio] integer]
genus nintadl {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => 0
		CODE { RET { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } }
	}
	[[xa]] functio nintadl operator - () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @NEG:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio nintadl operator ~ () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @INVERSE:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio logicum operator ! () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @ZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] functio ~nintadl operator = (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator += (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator *= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MUL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator /= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_DIV:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator %= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @U_MOD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator |= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @OR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator &= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @AND:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator #= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @XOR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator <<= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHL:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator >>= (nintadl src) {
		INTERFACE W 1 : THIS W 1 : UINT => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SHR:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator ++ () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @ADD:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~nintadl operator -- () {
		DATA DWORD 1
		INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), @SUB:W 1 W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] classis functio nintadl operator + (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @ADD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator - (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SUB:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator * (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MUL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator / (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_DIV:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator % (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_MOD:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator | (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @OR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator & (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @AND:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator # (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @XOR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator << (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHL:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio nintadl operator >> (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @SHR:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator == (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator != (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator < (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_L:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator > (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_G:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator <= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_LE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
	[[xa]] classis functio logicum operator >= (nintadl a, nintadl b) {
		INTERFACE W 1 : UINT W 1 : UINT => 1
		CODE { RET { @BLT:1 1=>1(R, @U_GE:W 1 W 1=>W 1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "4"] [[significatio] fractus]
genus frac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => 0
		CODE { RET { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } }
	}
	[[xa]] [[inline]] functio frac operator - () { INTERFACE W 1 : THIS => 4 : FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_NEG_32:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } } }
	[[xa]] [[inline]] functio logicum operator ! () { INTERFACE W 1 : THIS => 1 CODE { RET { @BLT:1 1=>1(R, @FP_ZERO_32:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } } }
	[[xa]] functio ~frac operator = (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator += (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_ADD_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator -= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_SUB_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator *= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_MUL_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator /= (frac src) {
		INTERFACE W 1 : THIS 4 : FLOAT => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_DIV_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator ++ () {
		DATA DWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_ADD_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~frac operator -- () {
		DATA DWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), @FP_SUB_32:4 4=>4(@PTR_FOLLOW:W 1=>4(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] [[inline]] classis functio frac operator + (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_ADD_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator - (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_SUB_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator * (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_MUL_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio frac operator / (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_DIV_32:4 4=>4(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator == (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_EQ_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator != (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NEQ_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator < (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_L_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator > (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_G_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator <= (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_LE_32:4 4=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator >= (frac a, frac b) {
		INTERFACE 4 : FLOAT 4 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_GE_32:4 4=>1(A[0], A[1])) } }
	}
}
[[innatum]] [[magnitudo] "8"] [[significatio] fractus]
genus dfrac {
	[[xa]] structor () {
		INTERFACE W 1 : THIS => 0
		CODE { RET }
	}
	[[xa]] structor (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => 0
		CODE { RET { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } }
	}
	[[xa]] [[inline]] functio dfrac operator - () { INTERFACE W 1 : THIS => 8 : FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_NEG_64:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } } }
	[[xa]] [[inline]] functio logicum operator ! () { INTERFACE W 1 : THIS => 1 CODE { RET { @BLT:1 1=>1(R, @FP_ZERO_64:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } } }
	[[xa]] functio ~dfrac operator = (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1]) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator += (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_ADD_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator -= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_SUB_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator *= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_MUL_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator /= (dfrac src) {
		INTERFACE W 1 : THIS 8 : FLOAT => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_DIV_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), A[1])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator ++ () {
		DATA QWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_ADD_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] functio ~dfrac operator -- () {
		DATA QWORD 1.0 INTERFACE W 1 : THIS => W 1
		CODE { EVAL { @BLT:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), @FP_SUB_64:8 8=>8(@PTR_FOLLOW:W 1=>8(A[0]), D[0])) } RET { @BLT:W 1 W 1=>W 1(R, A[0]) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator + (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_ADD_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator - (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_SUB_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator * (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_MUL_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio dfrac operator / (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_DIV_64:8 8=>8(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator == (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_EQ_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator != (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NEQ_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator < (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_L_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator > (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_G_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator <= (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_LE_64:8 8=>1(A[0], A[1])) } }
	}
	[[xa]] [[inline]] classis functio logicum operator >= (dfrac a, dfrac b) {
		INTERFACE 8 : FLOAT 8 : FLOAT => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_GE_64:8 8=>1(A[0], A[1])) } }
	}
}

nomen_alternum int = int32;
nomen_alternum nint = nint32;
nomen_alternum frac32 = frac;
nomen_alternum frac64 = dfrac;
nomen_alternum char = nint32;

dura logicum {
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:INT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:INT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura int8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:SINT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:SINT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura nint8 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:1=>1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @PTR_FOLLOW:W 1=>1(A[0])) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:1=>2(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:1=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:1=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:1=>W 1(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:1:INT=>4(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:1:INT=>8(@PTR_FOLLOW:W 1=>1(A[0]))) } }
	}
}
dura int16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:2:SINT=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:2:SINT=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
}
dura nint16 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:2=>2(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:2=>1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @PTR_FOLLOW:W 1=>2(A[0])) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:2=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:2=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:2=>W 1(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:2:INT=>4(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:2:INT=>8(@PTR_FOLLOW:W 1=>2(A[0]))) } }
	}
}
dura int32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:4:SINT=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:4:SINT=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura nint32 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:4=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:4=>2(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @PTR_FOLLOW:W 1=>4(A[0])) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:4=>W 1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:4:INT=>4(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:4:INT=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura int64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @S_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:8:SINT=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:8:SINT=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}
dura nint64 {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:8=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:8=>2(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @PTR_FOLLOW:W 1=>8(A[0])) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @U_RESIZE:8=>W 1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:8:INT=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:8:INT=>8(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}
dura intadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @S_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @S_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @S_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @S_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : UINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:W 1:SINT=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:W 1:SINT=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
}
dura nintadl {
	[[xa]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @NOTZERO:W 1=>W 1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : UINT
		CODE { RET { @BLT:1 1=>1(R, @U_RESIZE:W 1=>1(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : UINT
		CODE { RET { @BLT:2 2=>2(R, @U_RESIZE:W 1=>2(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : UINT
		CODE { RET { @BLT:4 4=>4(R, @U_RESIZE:W 1=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : UINT
		CODE { RET { @BLT:8 8=>8(R, @U_RESIZE:W 1=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @PTR_FOLLOW:W 1=>W 1(A[0])) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_GATHER_32:W 1:INT=>4(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_GATHER_64:W 1:INT=>8(@PTR_FOLLOW:W 1=>W 1(A[0]))) } }
	}
}
dura frac {
	[[xa]] [[inline]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NOTZERO_32:4=>1(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_32:4=>1:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : INT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_32:4=>1:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_32:4=>2:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : INT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_32:4=>2:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_32:4=>4:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : INT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_32:4=>4:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_32:4=>8:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : INT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_32:4=>8:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_32:4=>W 1:SINT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : INT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_32:4=>W 1:INT(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (dfrac) () {
		INTERFACE W 1 : THIS => 8 : FLOAT
		CODE { RET { @BLT:8 8=>8(R, @FP_RESIZE_32:4=>8(@PTR_FOLLOW:W 1=>4(A[0]))) } }
	}
}
dura dfrac {
	[[xa]] [[inline]] convertor (logicum) () {
		INTERFACE W 1 : THIS => 1
		CODE { RET { @BLT:1 1=>1(R, @FP_NOTZERO_64:8=>1(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int8) () {
		INTERFACE W 1 : THIS => 1 : SINT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_64:8=>1:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint8) () {
		INTERFACE W 1 : THIS => 1 : INT
		CODE { RET { @BLT:1 1=>1(R, @FP_INTEGER_64:8=>1:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int16) () {
		INTERFACE W 1 : THIS => 2 : SINT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_64:8=>2:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint16) () {
		INTERFACE W 1 : THIS => 2 : INT
		CODE { RET { @BLT:2 2=>2(R, @FP_INTEGER_64:8=>2:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int32) () {
		INTERFACE W 1 : THIS => 4 : SINT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_64:8=>4:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint32) () {
		INTERFACE W 1 : THIS => 4 : INT
		CODE { RET { @BLT:4 4=>4(R, @FP_INTEGER_64:8=>4:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (int64) () {
		INTERFACE W 1 : THIS => 8 : SINT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_64:8=>8:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nint64) () {
		INTERFACE W 1 : THIS => 8 : INT
		CODE { RET { @BLT:8 8=>8(R, @FP_INTEGER_64:8=>8:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (intadl) () {
		INTERFACE W 1 : THIS => W 1 : SINT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_64:8=>W 1:SINT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (nintadl) () {
		INTERFACE W 1 : THIS => W 1 : INT
		CODE { RET { @BLT:W 1 W 1=>W 1(R, @FP_INTEGER_64:8=>W 1:INT(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
	[[xa]] [[inline]] convertor (frac) () {
		INTERFACE W 1 : THIS => 4 : FLOAT
		CODE { RET { @BLT:4 4=>4(R, @FP_RESIZE_64:8=>4(@PTR_FOLLOW:W 1=>8(A[0]))) } }
	}
}

[[xa]] functio logicum operator == (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @EQ:W 1 W 1=>W 1(A[0], A[1])) } }
}
[[xa]] functio logicum operator != (@nihil a, @nihil b) {
	INTERFACE W 1 : - W 1 : - => 1
	CODE { RET { @BLT:1 1=>1(R, @NEQ:W 1 W 1=>W 1(A[0], A[1])) } }
}

spatium math {
	dura .frac {
		constatus pi = frac(3.14159265358979323846);
		constatus e = frac(2.71828182845904523536);
	}
	dura .dfrac {
		constatus pi = 3.14159265358979323846;
		constatus e = 2.71828182845904523536;
	}

	[[xa]] [[inline]]		functio int8	abs(int8 valor)		{ INTERFACE 1:SINT=>1:SINT CODE { RET { @BLT:1 1=>1(R, @ABS:1=>1(A[0])) } } }
	[[xa]] [[inline]]		functio int16	abs(int16 valor)	{ INTERFACE 2:SINT=>2:SINT CODE { RET { @BLT:2 2=>2(R, @ABS:2=>2(A[0])) } } }
	[[xa]] [[inline]]		functio int32	abs(int32 valor)	{ INTERFACE 4:SINT=>4:SINT CODE { RET { @BLT:4 4=>4(R, @ABS:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio int64	abs(int64 valor)	{ INTERFACE 8:SINT=>8:SINT CODE { RET { @BLT:8 8=>8(R, @ABS:8=>8(A[0])) } } }
	[[xa]] [[inline]]		functio intadl	abs(intadl valor)	{ INTERFACE W 1:SINT=>W 1:SINT CODE { RET { @BLT:W 1 W 1=>W 1(R, @ABS:W 1=>W 1(A[0])) } } }
	[[xa]] [[inline]]		functio frac	abs(frac valor)		{ INTERFACE 4:FLOAT=>4:FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_ABS_32:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio dfrac	abs(dfrac valor)	{ INTERFACE 8:FLOAT=>8:FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_ABS_64:8=>8(A[0])) } } }

	[[xa]] [[inline]]		functio frac	radix(frac valor)	{ INTERFACE 4:FLOAT=>4:FLOAT CODE { RET { @BLT:4 4=>4(R, @FP_SQRT_32:4=>4(A[0])) } } }
	[[xa]] [[inline]]		functio dfrac	radix(dfrac valor)	{ INTERFACE 8:FLOAT=>8:FLOAT CODE { RET { @BLT:8 8=>8(R, @FP_SQRT_64:8=>8(A[0])) } } }
}
spatium errores {
	[error] constatus error_nullus		= 0x00;
	[error] constatus implantatio_nulla	= 0x01;
	[error] constatus memoria_nulla		= 0x02;
	[error] constatus argumentum_falsum	= 0x03;
	[error] constatus efformatio_falsa	= 0x04;
	[error] constatus habitus_falsus	= 0x05;
	[error] constatus ie_falsum			= 0x06;
	[error] constatus xe_defectus		= 0x07;

	[sub_error ie_falsum] constatus ie_error_nullus					= 0x00;
	[sub_error ie_falsum] constatus ie_error_ignotus				= 0x01;
	[sub_error ie_falsum] constatus ie_lima_nulla					= 0x02;
	[sub_error ie_falsum] constatus ie_semita_nulla					= 0x03;
	[sub_error ie_falsum] constatus ie_limae_apertae_nimium			= 0x04;
	[sub_error ie_falsum] constatus ie_permissio_nulla				= 0x05;
	[sub_error ie_falsum] constatus ie_manubrium_defectum			= 0x06;
	[sub_error ie_falsum] constatus ie_memoria_nulla				= 0x07;
	[sub_error ie_falsum] constatus ie_machinatio_defecta			= 0x08;
	[sub_error ie_falsum] constatus ie_legere_sole					= 0x09;
	[sub_error ie_falsum] constatus ie_spatium_disci_nullum			= 0x0A;
	[sub_error ie_falsum] constatus ie_lima_preexistat				= 0x0B;
	[sub_error ie_falsum] constatus ie_implantatio_nulla			= 0x0C;
	[sub_error ie_falsum] constatus ie_collectorium_vacuum_non		= 0x0D;
	[sub_error ie_falsum] constatus ie_collectorium_currens_est		= 0x0E;
	[sub_error ie_falsum] constatus ie_machinatio_idem_non			= 0x0F;
	[sub_error ie_falsum] constatus ie_nomen_semitae_defectum		= 0x10;
	[sub_error ie_falsum] constatus ie_nomen_limae_largum_nimium	= 0x11;
	[sub_error ie_falsum] constatus ie_lima_larga_nimium			= 0x12;
	[sub_error ie_falsum] constatus ie_legere_falsum				= 0x13;
	[sub_error ie_falsum] constatus ie_scribere_falsum				= 0x14;
	[sub_error ie_falsum] constatus ie_creare_falsum				= 0x15;
	[sub_error ie_falsum] constatus ie_aperire_falsum				= 0x16;

	[sub_error xe_defectus] constatus xe_error_nullus			= 0x00;
	[sub_error xe_defectus] constatus xe_modulus_nullus			= 0x01;
	[sub_error xe_defectus] constatus xe_imago_falsa			= 0x02;
	[sub_error xe_defectus] constatus xe_functio_falsa			= 0x03;
	[sub_error xe_defectus] constatus xe_abi_functionis_falsa	= 0x04;
	[sub_error xe_defectus] constatus xe_symbolus_duplicatus	= 0x05;
	[sub_error xe_defectus] constatus xe_adhaesio_defecta		= 0x06;
	[sub_error xe_defectus] constatus xe_importus_falsus		= 0x07;
	[sub_error xe_defectus] constatus xe_librarium_nullum		= 0x08;
	[sub_error xe_defectus] constatus xe_lib_importus_falsus	= 0x09;
	[sub_error xe_defectus] constatus xe_allocatus_defectus		= 0x0A;
	[sub_error xe_defectus] constatus xe_initium_defectum		= 0x0B;
}
enumeratio tactus {
	back		= 0x08,
	tab			= 0x09,
	enter		= 0x0D,
	shift		= 0x10,
	ctrl		= 0x11,
	alt			= 0x12,
	system		= 0xFFFF,
	pause		= 0x13,
	caps_lock	= 0x14,
	escape		= 0x1B,
	l_shift		= 0xA0,
	r_shift		= 0xA1,
	l_ctrl		= 0xA2,
	r_ctrl		= 0xA3,
	l_alt		= 0xA4,
	r_alt		= 0xA5,
	l_system	= 0x5B,
	r_system	= 0x5C,
	space		= ' ',
	page_up		= 0x21,
	page_down	= 0x22,
	end			= 0x23,
	home		= 0x24,
	left		= 0x25,
	up			= 0x26,
	right		= 0x27,
	down		= 0x28,
	select		= 0x29,
	print		= 0x2A,
	execute		= 0x2B,
	prnt_scrn	= 0x2C,
	insert		= 0x2D,
	delete		= 0x2E,
	help		= 0x2F,
	N0			= '0',
	N1			= '1',
	N2			= '2',
	N3			= '3',
	N4			= '4',
	N5			= '5',
	N6			= '6',
	N7			= '7',
	N8			= '8',
	N9			= '9',
	A			= 'A',
	B			= 'B',
	C			= 'C',
	D			= 'D',
	E			= 'E',
	F			= 'F',
	G			= 'G',
	H			= 'H',
	I			= 'I',
	J			= 'J',
	K			= 'K',
	L			= 'L',
	M			= 'M',
	N			= 'N',
	O			= 'O',
	P			= 'P',
	Q			= 'Q',
	R			= 'R',
	S			= 'S',
	T			= 'T',
	U			= 'U',
	V			= 'V',
	W			= 'W',
	X			= 'X',
	Y			= 'Y',
	Z			= 'Z',
	sleep		= 0x5F,
	NP0			= 0x60,
	NP1			= 0x61,
	NP2			= 0x62,
	NP3			= 0x63,
	NP4			= 0x64,
	NP5			= 0x65,
	NP6			= 0x66,
	NP7			= 0x67,
	NP8			= 0x68,
	NP9			= 0x69,
	multiply	= 0x6A,
	add			= 0x6B,
	separator	= 0x6C,
	subtract	= 0x6D,
	decimal		= 0x6E,
	divide		= 0x6F,
	F1			= 0x70,
	F2			= 0x71,
	F3			= 0x72,
	F4			= 0x73,
	F5			= 0x74,
	F6			= 0x75,
	F7			= 0x76,
	F8			= 0x77,
	F9			= 0x78,
	F10			= 0x79,
	F11			= 0x7A,
	F12			= 0x7B,
	F13			= 0x7C,
	F14			= 0x7D,
	F15			= 0x7E,
	F16			= 0x7F,
	F17			= 0x80,
	F18			= 0x81,
	F19			= 0x82,
	F20			= 0x83,
	F21			= 0x84,
	F22			= 0x85,
	F23			= 0x86,
	F24			= 0x87,
	num_lock	= 0x90,
	scrl_lock	= 0x91,
	oem_plus	= 0xBB,
	oem_comma	= 0xBC,
	oem_minus	= 0xBD,
	oem_prd		= 0xBE,
	oem_clear	= 0xFE,
	vol_mute	= 0xAD,
	vol_down	= 0xAE,
	vol_up		= 0xAF,
	OEM1		= 0xBA,
	OEM2		= 0xBF,
	OEM3		= 0xC0,
	OEM4		= 0xDB,
	OEM5		= 0xDC,
	OEM6		= 0xDD,
	OEM7		= 0xDE,
	OEM8		= 0xFF,
}