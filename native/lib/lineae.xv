auxilium attributum ("NomenModuli") = "Liber Lineae";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2024";
auxilium attributum ("Versio") = "1.0.0.1";

importa memoria;

[[systema] libera]

spatium winapi {
	[[importa] "CharUpperW"] [[importa_de] "user32"] [stdcall "1"]
	functio nintadl CharUpper(nintadl chr);
	[[importa] "CharLowerW"] [[importa_de] "user32"] [stdcall "1"]
	functio nintadl CharLower(nintadl chr);
}
spatium lineae {
	functio char lege_characterem(@nihil ex, ~int ex_long, int ex_cdx)
	{
		si (ex_cdx == linea.codex.ascii) {
			si (ex_long > 0) { ex_long = 1; responde (@nint8)(ex)^ < nint8(128) ? (@nint8)(ex)^ : '?'; }
			alioqui { ex_long = 0; responde 0; }
		} alioqui si (ex_cdx == linea.codex.utf8) {
			var data = (@nint8)(ex);
			si (ex_long >= 4 && data[0] & nint8(0xB0) == nint8(0xB0)) {
				ex_long = 4;
				responde (char(data[0] & nint8(0x07)) << char(18)) | (char(data[1] & nint8(0x3F)) << char(12)) |
					(char(data[2] & nint8(0x3F)) << char(6)) | char(data[3] & nint8(0x3F));
			} alioqui si (ex_long >= 3 && data[0] & nint8(0xB0) == nint8(0xA0)) {
				ex_long = 3;
				responde (char(data[0] & nint8(0x0F)) << char(12)) | (char(data[1] & nint8(0x3F)) << char(6)) | char(data[2] & nint8(0x3F));
			} alioqui si (ex_long >= 2 && data[0] & nint8(0xA0) == nint8(0x80)) {
				ex_long = 2;
				responde (char(data[0] & nint8(0x1F)) << char(6)) | char(data[1] & nint8(0x3F));
			} alioqui si (ex_long >= 1 && data[0] & nint8(0x80) == nint8(0x00)) {
				ex_long = 1;
				responde char(data[0] & nint8(0x7F));
			} alioqui { ex_long = 0; responde 0; }
		} alioqui si (ex_cdx == linea.codex.utf16) {
			var data = (@nint16)(ex);
			si (ex_long >= 4 && data[0] & nint16(0xFC00) == nint16(0xD800)) {
				ex_long = 4;
				responde ((char(data[0] & nint16(0x03FF)) << char(10)) | char(data[1] & nint16(0x03FF))) + char(0x10000);
			} alioqui si (ex_long >= 2 && data[0] & nint16(0xFC00) != nint16(0xD800)) {
				ex_long = 2;
				responde data[0];
			} alioqui { ex_long = 0; responde 0; }
		} alioqui si (ex_cdx == linea.codex.utf32) {
			si (ex_long >= 4) {
				ex_long = 4;
				responde (@char)(ex)^;
			} alioqui { ex_long = 0; responde 0; }
		} alioqui { ex_long = 0; responde 0; }
	}
	functio nihil scribe_characterem(@nihil in, ~int in_long, int in_cdx, char chr)
	{
		si (in_cdx == linea.codex.ascii) {
			si (chr >= char(0x80)) (@nint8)(in)^ = '?';
			alioqui (@nint8)(in)^ = chr;
			in_long = 1;
		} alioqui si (in_cdx == linea.codex.utf8) {
			var data = (@nint8)(in);
			si (chr > char(0xFFFF)) {
				data[0] = ((chr >> char(18)) & char(0x07)) | char(0xF0);
				data[1] = ((chr >> char(12)) & char(0x3F)) | char(0x80);
				data[2] = ((chr >> char(6)) & char(0x3F)) | char(0x80);
				data[3] = (chr & char(0x3F)) | char(0x80);
				in_long = 4;
			} alioqui si (chr > char(0x7FF)) {
				data[0] = ((chr >> char(12)) & char(0x0F)) | char(0xE0);
				data[1] = ((chr >> char(6)) & char(0x3F)) | char(0x80);
				data[2] = (chr & char(0x3F)) | char(0x80);
				in_long = 3;
			} alioqui si (chr > char(0x7F)) {
				data[0] = ((chr >> char(6)) & char(0x1F)) | char(0xC0);
				data[1] = (chr & char(0x3F)) | char(0x80);
				in_long = 2;
			} alioqui {
				data[0] = chr;
				in_long = 1;
			}
		} alioqui si (in_cdx == linea.codex.utf16) {
			var data = (@nint16)(in);
			si (chr > char(0xFFFF)) {
				var v = chr - char(0x10000);
				data[0] = ((v >> char(10)) & char(0x3FF)) | char(0xD800);
				data[1] = (v & char(0x3FF)) | char(0xDC00);
				in_long = 4;
			} alioqui {
				data[0] = chr;
				in_long = 2;
			}
		} alioqui si (in_cdx == linea.codex.utf32) {
			(@char)(in)^ = chr;
			in_long = 4;
		} alioqui { in_long = 0; }
	}
	functio int mensura_longitudinem(@char linea, int cdx)
	{
		int mes = 0, i = 0;
		dum (linea[i]) {
			char chr; int l;
			scribe_characterem(@chr, l, cdx, linea[i]);
			i++; mes += l;
		}
		responde mes;
	}
	functio int longitudo_characteris(int cdx)
	{
		si (cdx == linea.codex.utf32) responde 4;
		alioqui si (cdx == linea.codex.utf16) responde 2;
		alioqui responde 1;
	}
}

genus linea_utf16 {
	@nint16 _data;

	int longitudo { adipisce { int l = 0; dum (_data[l]) l++; responde l; } }

	structor () { _data = nullus; }
	structor motus (~linea_utf16 s) { _data = s._data; s._data = nullus; }
	destructor () { memoria.dimitte(_data); }

	structor (~linea_utf16 valor) iacit
	{
		int long = valor.longitudo;
		_data = (@nint16)(memoria.alloca((long + 1) * 2));
		si (_data == nullus) iace errores.memoria_nulla;
		memoria.exscribe(_data, valor._data, (long + 1) * 2);
	}
	structor (@char valor) iacit
	{
		var long = lineae.mensura_longitudinem(valor, linea.codex.utf16);
		_data = (@nint16)(memoria.alloca(long + 2));
		si (_data == nullus) iace errores.memoria_nulla;
		int i = 0, l;
		nintadl p = 0;
		dum (sic) {
			lineae.scribe_characterem((@nihil)(nintadl(_data) + p), l, linea.codex.utf16, valor[i]);
			si (!valor[i]) exi;
			i++; p += l;
		}
	}
	convertor (@nint16) () { responde _data; }
}
genus linea {
	@char _data;

	int longitudo { [[thiscall_nullum]] adipisce { si (_data == nullus) responde 0; int l = 0; dum (_data[l]) l++; responde l; } }

	functio int initus() { responde 0; }
	functio int finis() { responde longitudo - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde longitudo; }

	constatus radix_bina		= "01";
	constatus radix_octava		= "01234567";
	constatus radix_decima		= "0123456789";
	constatus radix_sextadecima	= "0123456789ABCDEF";

	structor () { _data = nullus; }
	structor motus (~linea s) { _data = s._data; s._data = nullus; }
	destructor () { memoria.dimitte(_data); }

	@char _data_effectiva { adipisce { responde _data == nullus ? "" : _data; } }

	[[thiscall_nullum]] structor (~linea valor) iacit
	{
		si (valor._data == nullus) {
			_data = nullus;
		} alioqui {
			int long = valor.longitudo;
			_data = (@char)(memoria.alloca((long + 1) * 4));
			si (_data == nullus) iace errores.memoria_nulla;
			memoria.exscribe(_data, valor._data, (long + 1) * 4);
		}
	}
	[[thiscall_nullum]] structor (@char valor) iacit
	{
		int long = 0;
		dum (valor[long]) long++;
		si (long) {
			_data = (@char)(memoria.alloca((long + 1) * 4));
			si (_data == nullus) iace errores.memoria_nulla;
			memoria.exscribe(_data, valor, (long + 1) * 4);
		} alioqui _data = nullus;
	}
	convertor (@char) () { responde _data_effectiva; }
	convertor (linea_utf16) () iacit { responde linea_utf16(_data_effectiva); }

	enumeratio codex {
		ignotus		= 0x00,
		ascii		= 0x01,
		utf8		= 0x02,
		utf16		= 0x03,
		utf32		= 0x04,
	}

	classis functio @char _divide(@char num) iacit
	{
		@char valor = (@char)(memoria.alloca(4 * num[0] + 12));
		si (valor == nullus) { memoria.dimitte(num); iace errores.memoria_nulla; }
		valor[0] = num[0];
		valor[1] = num[1];
		char vec = 0;
		per (int i : [2, int(num[0]) + 1]) {
			char num = vec * char(10) + num[i];
			valor[i] = num / char(2);
			vec = num % char(2);
		}
		si (vec) {
			valor[0]++;
			valor[int(valor[0]) + 1] = 5;
		}
		memoria.dimitte(num);
		responde valor;
	}
	classis functio @char _potentia_bina(int pt) iacit
	{
		si (pt >= 0) {
			int long = pt / 2 + 6;
			@char valor = (@char)(memoria.alloca(4 * long + 8));
			si (valor == nullus) iace errores.memoria_nulla;
			memoria.relabe(valor, 4 * long + 8);
			valor[long + 1] = 1;
			valor[0] = valor[1] = long;
			char vec;
			int ns = long;
			per (int j = 0; j < pt; j++) {
				vec = 0;
				per (var i : ~[2, long + 1]) {
					char num = valor[i] * char(2) + vec;
					valor[i] = num % char(10);
					vec = num / char(10);
					si (!vec && i <= ns) { ns = i; exi; }
				}
			}
			responde valor;
		} alioqui {
			@char unus = (@char)(memoria.alloca(12));
			unus[0] = unus[1] = unus[2] = 1;
			per (int i = 0; i < -pt; i++) unus = _divide(unus);
			responde unus;
		}
	}
	classis functio @char _adde(@char ad, @char valor)
	{
		ordo [2] char zerum;
		zerum[0] = zerum[1] = 0;
		@char addendum = ad == nullus ? @zerum[0] : ad;
		char ni1 = addendum[1];
		char ni2 = valor[1];
		char nf1 = addendum[0] - addendum[1];
		char nf2 = valor[0] - valor[1];
		char ni = (ni1 > ni2 ? ni1 : ni2) + char(1);
		char nf = nf1 > nf2 ? nf1 : nf2;
		@char resp = (@char)(memoria.alloca(char(4) * (ni + nf + char(2))));
		si (resp == nullus) { memoria.dimitte(ad); responde nullus; }
		resp[0] = ni + nf;
		resp[1] = ni;
		char vec = 0;
		per (var i : ~[2, int(resp[0]) + 1]) {
			var ir = i - int(resp[1]) - 1;
			var i1 = ir + int(addendum[1]) + 1;
			var i2 = ir + int(valor[1]) + 1;
			var num1 = (i1 >= 2 && i1 < int(addendum[0]) + 2) ? addendum[i1] : 0;
			var num2 = (i2 >= 2 && i2 < int(valor[0]) + 2) ? valor[i2] : 0;
			var num = num1 + num2 + vec;
			resp[i] = num % char(10);
			vec = num / char(10);
		}
		memoria.dimitte(ad);
		responde resp;
	}
	classis functio nihil _concava(@char num, int prec)
	{
		int long = 2 + int(num[0]);
		int i = 2;
		dum (i < long && !num[i]) i++;
		int initium = i;
		dum (i < long && i - initium < prec) i++;
		char vec = 0;
		si (i < long && num[i] >= char(5)) vec = 1;
		per (var j : [i, long - 1]) num[j] = 0;
		per (var j : ~[2, i - 1]) {
			char ad = num[j] + vec;
			num[j] = ad % char(10);
			vec = ad / char(10);
			si (!vec) exi;
		}
		initium = 2;
		i = num[1] + char(1);
		dum (initium < i && !num[initium]) initium++;
		si (initium > 2) {
			per (i : [2, long + 1 - initium]) num[i] = num[i + initium - 2];
			num[0] -= initium - 2;
			num[1] -= initium - 2;
		}
		dum (num[1] != num[0] && !num[num[0] + 1]) num[0]--;
	}
	functio nihil _ini_ex_numero(logicum signum, nint64 valor, @char radix, int long) iacit
	{
		si (radix == nullus || long < 0 || long > 0x40) iace errores.argumentum_falsum;
		int long_rdx = 0;
		dum (radix[long_rdx]) long_rdx++;
		si (long_rdx < 2) iace errores.argumentum_falsum;
		@char ord = (@char)(memoria.alloca(0x200));
		si (ord == nullus) iace errores.memoria_nulla;
		int long_scr = 0;
		var vlr = valor;
		fac {
			int n = vlr % nint64(long_rdx);
			vlr /= long_rdx;
			ord[long_scr] = radix[n];
			long_scr++;
		} dum (vlr);
		si (long_scr == 0) { ord[long_scr] = radix[0]; long_scr++; }
		dum (long_scr < long) { ord[long_scr] = radix[0]; long_scr++; }
		_data = (@char)(memoria.alloca(4 * (long_scr + 1 + int(signum))));
		si (_data == nullus) { memoria.dimitte(ord); iace errores.memoria_nulla;} 
		int long_num = long_scr;
		long_scr = 0;
		si (signum) { _data[long_scr] = '-'; long_scr++; }
		per (var i = long_num - 1; i >= 0; i--) { _data[long_scr] = ord[i]; long_scr++; }
		_data[long_scr] = 0;
		memoria.dimitte(ord);
	}
	functio nihil _ini_ex_fractione(logicum signum, int exp, nint64 data, int long, char punctum, int prec) iacit
	{
		var radix = _potentia_bina(exp);
		@char numerus = nullus;
		int l = long;
		dum (l) {
			si (data & (nint64(1) << nint64(l - 1))) {
				numerus = _adde(numerus, radix);
				si (numerus == nullus) {
					memoria.dimitte(radix);
					iace errores.memoria_nulla;
				}
			}
			proba radix = _divide(radix); cape { memoria.dimitte(numerus); iace errores.memoria_nulla; }
			l--;
		}
		memoria.dimitte(radix);
		_concava(numerus, prec);
		logicum punctum_habet = numerus[0] != numerus[1];
		_data = (@char)(memoria.alloca(4 * (int(numerus[0]) + int(signum) + int(punctum_habet) + 1)));
		si (_data == nullus) { memoria.dimitte(numerus); iace errores.memoria_nulla; }
		int ps = 0;
		si (signum) { _data[ps] = '-'; ps++; }
		per (int i : [2, int(numerus[0]) + 1]) {
			si (i == int(numerus[1]) + 2) { _data[ps] = punctum; ps++; }
			_data[ps] = char('0') + numerus[i]; ps++;
		}
		_data[ps] = 0;
		memoria.dimitte(numerus);
	}
	functio nihil _ini_ex_linea(@char ln) iacit
	{
		int long = 0;
		dum (ln[long]) long++;
		long = 4 * (long + 1);
		_data = (@char)(memoria.alloca(long));
		si (_data == nullus) iace errores.memoria_nulla;
		memoria.exscribe(_data, ln, long);
	}
	
	[[thiscall_nullum]] structor (int8 valor) iacit { _ini_ex_numero(valor < int8(0), math.abs(valor), radix_decima, 1); }
	[[thiscall_nullum]] structor (nint8 valor) iacit { _ini_ex_numero(non, valor, radix_decima, 1); }
	[[thiscall_nullum]] structor (int16 valor) iacit { _ini_ex_numero(valor < int16(0), math.abs(valor), radix_decima, 1); }
	[[thiscall_nullum]] structor (nint16 valor) iacit { _ini_ex_numero(non, valor, radix_decima, 1); }
	[[thiscall_nullum]] structor (int32 valor) iacit { _ini_ex_numero(valor < int32(0), math.abs(valor), radix_decima, 1); }
	[[thiscall_nullum]] structor (nint32 valor) iacit { _ini_ex_numero(non, valor, radix_decima, 1); }
	[[thiscall_nullum]] structor (int64 valor) iacit { _ini_ex_numero(valor < int64(0), math.abs(valor), radix_decima, 1); }
	[[thiscall_nullum]] structor (nint64 valor) iacit { _ini_ex_numero(non, valor, radix_decima, 1); }
	[[thiscall_nullum]] structor (intadl valor) iacit { _ini_ex_numero(valor < intadl(0), math.abs(valor), radix_decima, 1); }
	[[thiscall_nullum]] structor (nintadl valor) iacit { _ini_ex_numero(non, valor, radix_decima, 1); }
	[[thiscall_nullum]] structor (nint8 valor, ~linea radix, int long_min) iacit { _ini_ex_numero(non, valor, radix, long_min); }
	[[thiscall_nullum]] structor (nint16 valor, ~linea radix, int long_min) iacit { _ini_ex_numero(non, valor, radix, long_min); }
	[[thiscall_nullum]] structor (nint32 valor, ~linea radix, int long_min) iacit { _ini_ex_numero(non, valor, radix, long_min); }
	[[thiscall_nullum]] structor (nint64 valor, ~linea radix, int long_min) iacit { _ini_ex_numero(non, valor, radix, long_min); }
	[[thiscall_nullum]] structor (nintadl valor, ~linea radix, int long_min) iacit { _ini_ex_numero(non, valor, radix, long_min); }
	[[thiscall_nullum]] structor (@nihil valor) iacit { _ini_ex_numero(non, nintadl(valor), radix_sextadecima, magnitudo(nintadl) * 2); }

	[[thiscall_nullum]] structor (frac valor) iacit
	{
		var data = (@nint32)(@valor)^;
		var exp = int((nint32(data) & nint32(0x7F800000)) >> nint32(23));
		var num = data & nint32(0x007FFFFF);
		var sgn = logicum(data & nint32(0x80000000));
		si (exp == 0) {
			si (num == nint32(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -126, num, 24, '.', 7);
		} alioqui si (exp == 0xFF) {
			si (num == nint32(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint32(0x00800000);
			_ini_ex_fractione(sgn, exp - 127, num, 24, '.', 7);
		}
	}
	[[thiscall_nullum]] structor (frac valor, char punctum) iacit
	{
		var data = (@nint32)(@valor)^;
		var exp = int((nint32(data) & nint32(0x7F800000)) >> nint32(23));
		var num = data & nint32(0x007FFFFF);
		var sgn = logicum(data & nint32(0x80000000));
		si (exp == 0) {
			si (num == nint32(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -126, num, 24, punctum, 7);
		} alioqui si (exp == 0xFF) {
			si (num == nint32(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint32(0x00800000);
			_ini_ex_fractione(sgn, exp - 127, num, 24, punctum, 7);
		}
	}
	[[thiscall_nullum]] structor (frac valor, char punctum, int long) iacit
	{
		var data = (@nint32)(@valor)^;
		var exp = int((nint32(data) & nint32(0x7F800000)) >> nint32(23));
		var num = data & nint32(0x007FFFFF);
		var sgn = logicum(data & nint32(0x80000000));
		si (exp == 0) {
			si (num == nint32(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -126, num, 24, punctum, long);
		} alioqui si (exp == 0xFF) {
			si (num == nint32(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint32(0x00800000);
			_ini_ex_fractione(sgn, exp - 127, num, 24, punctum, long);
		}
	}
	[[thiscall_nullum]] structor (dfrac valor) iacit
	{
		var data = (@nint64)(@valor)^;
		var exp = int((nint64(data) & nint64(0x7FF0000000000000)) >> nint64(52));
		var num = data & nint64(0x000FFFFFFFFFFFFF);
		var sgn = logicum(data & nint64(0x8000000000000000));
		si (exp == 0) {
			si (num == nint64(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -1022, num, 53, '.', 16);
		} alioqui si (exp == 0x7FF) {
			si (num == nint64(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint64(0x0010000000000000);
			_ini_ex_fractione(sgn, exp - 1023, num, 53, '.', 16);
		}
	}
	[[thiscall_nullum]] structor (dfrac valor, char punctum) iacit
	{
		var data = (@nint64)(@valor)^;
		var exp = int((nint64(data) & nint64(0x7FF0000000000000)) >> nint64(52));
		var num = data & nint64(0x000FFFFFFFFFFFFF);
		var sgn = logicum(data & nint64(0x8000000000000000));
		si (exp == 0) {
			si (num == nint64(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -1022, num, 53, punctum, 16);
		} alioqui si (exp == 0x7FF) {
			si (num == nint64(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint64(0x0010000000000000);
			_ini_ex_fractione(sgn, exp - 1023, num, 53, punctum, 16);
		}
	}
	[[thiscall_nullum]] structor (dfrac valor, char punctum, int long) iacit
	{
		var data = (@nint64)(@valor)^;
		var exp = int((nint64(data) & nint64(0x7FF0000000000000)) >> nint64(52));
		var num = data & nint64(0x000FFFFFFFFFFFFF);
		var sgn = logicum(data & nint64(0x8000000000000000));
		si (exp == 0) {
			si (num == nint64(0)) _ini_ex_linea("0");
			alioqui _ini_ex_fractione(sgn, -1022, num, 53, punctum, long);
		} alioqui si (exp == 0x7FF) {
			si (num == nint64(0)) _ini_ex_linea(sgn ? "-\x221E" : "+\x221E");
			alioqui _ini_ex_linea("NF");
		} alioqui {
			num |= nint64(0x0010000000000000);
			_ini_ex_fractione(sgn, exp - 1023, num, 53, punctum, long);
		}
	}

	[[thiscall_nullum]] structor (logicum valor) iacit { _ini_ex_linea(valor ? "sic" : "non"); }
	[[thiscall_nullum]] structor (char valor, int long) iacit
	{
		si (long > 0) {
			_data = (@char)(memoria.alloca(4 * long + 4));
			si (_data == nullus) iace errores.memoria_nulla;
			per (int i = 0; i < long; i++) _data[i] = valor;
			_data[long] = 0;
		} alioqui _data = nullus;
	}
	[[thiscall_nullum]] structor (@nihil valor, int long, codex cdx) iacit
	{
		si (long > 0) {
			int lc = 0, ls = long * lineae.longitudo_characteris(cdx);
			var v = (@nint8)(valor);
			dum (ls) {
				int l = ls;
				char c = lineae.lege_characterem(v, l, cdx);
				si (!l || !c) exi;
				ls -= l;
				lc++;
				v = @v[l];
			}
			si (!lc) { _data = nullus; responde; }
			_data = (@char)(memoria.alloca(4 * (lc + 1)));
			si (_data == nullus) iace errores.memoria_nulla;
			v = (@nint8)(valor);
			per (var i : [0, lc - 1]) {
				int l = 4;
				_data[i] = lineae.lege_characterem(v, l, cdx);
				v = @v[l];
			}
			_data[lc] = 0;
		} alioqui si (long < 0) {
			int lc = 0;
			var v = (@nint8)(valor);
			dum (sic) {
				int l = 4;
				char c = lineae.lege_characterem(v, l, cdx);
				si (!l || !c) exi;
				lc++;
				v = @v[l];
			}
			si (!lc) { _data = nullus; responde; }
			_data = (@char)(memoria.alloca(4 * (lc + 1)));
			si (_data == nullus) iace errores.memoria_nulla;
			v = (@nint8)(valor);
			per (var i : [0, lc - 1]) {
				int l = 4;
				_data[i] = lineae.lege_characterem(v, l, cdx);
				v = @v[l];
			}
			_data[lc] = 0;
		} alioqui _data = nullus;
	}

	[[thiscall_nullum]] functio ~linea operator = (~linea valor) iacit
	{
		si (ego == @valor) responde ego^;
		si (valor._data == nullus) {
			memoria.dimitte(_data);
			_data = nullus;
		} alioqui {
			int l = 4 * (valor.longitudo + 1);
			var data = (@char)(memoria.alloca(l));
			si (data == nullus) iace errores.memoria_nulla;
			memoria.exscribe(data, valor._data_effectiva, l);
			memoria.dimitte(_data);
			_data = data;
		}
		responde ego^;
	}
	[[thiscall_nullum]] functio ~linea operator = (@char valor) iacit
	{
		int l = 0;
		dum (valor[l]) l++;
		si (l) {
			l = 4 * (l + 1);
			var data = (@char)(memoria.alloca(l));
			si (data == nullus) iace errores.memoria_nulla;
			memoria.exscribe(data, valor, l);
			memoria.dimitte(_data);
			_data = data;
		} alioqui {
			memoria.dimitte(_data);
			_data = nullus;
		}
		responde ego^;
	}
	[[thiscall_nullum]] functio ~linea operator += (~linea valor) iacit
	{
		si (ego == @valor) {
			int long = 4 * longitudo;
			si (long) {
				var data = (@char)(memoria.alloca(2 * long + 4));
				si (data == nullus) iace errores.memoria_nulla;
				memoria.exscribe(data, _data_effectiva, long);
				memoria.exscribe(@data[longitudo], _data_effectiva, long + 4);
				memoria.dimitte(_data);
				_data = data;
			}
		} alioqui {
			int long1 = 4 * longitudo;
			int long2 = 4 * valor.longitudo;
			si (long1 + long2) {
				var data = (@char)(memoria.alloca(long1 + long2 + 4));
				si (data == nullus) iace errores.memoria_nulla;
				memoria.exscribe(data, _data_effectiva, long1);
				memoria.exscribe(@data[longitudo], valor._data_effectiva, long2 + 4);
				memoria.dimitte(_data);
				_data = data;
			}
		}
		responde ego^;
	}
	[[thiscall_nullum]] functio char operator [] (int index) { responde _data_effectiva[index]; }

	classis functio linea operator + (~linea a, ~linea b) iacit
	{
		int long1 = 4 * a.longitudo;
		int long2 = 4 * b.longitudo;
		si (long1 + long2) {
			var data = (@char)(memoria.alloca(long1 + long2 + 4));
			si (data == nullus) iace errores.memoria_nulla;
			memoria.exscribe(data, a._data_effectiva, long1);
			memoria.exscribe(@data[a.longitudo], b._data_effectiva, long2 + 4);
			linea resp;
			resp._data = data;
			responde resp;
		} alioqui responde linea();
	}
	classis functio int operator <=> (~linea a, ~linea b)
	{
		int i = 0;
		dum (sic) {
			si (a[i] < b[i]) responde -1;
			alioqui si (a[i] > b[i]) responde 1;
			alioqui si (!a[i]) responde 0;
			i++;
		}
	}
	classis functio int operator # (~linea a, ~linea b)
	{
		int i = 0;
		dum (sic) {
			int l1 = 4, l2 = 4;
			ordo [4] nint16 utf16;
			lineae.scribe_characterem(@utf16[0], l1, codex.utf16, a[i]);
			lineae.scribe_characterem(@utf16[2], l2, codex.utf16, b[i]);
			si (l1 == 2 && l2 == 2) {
				utf16[0] = winapi.CharUpper(utf16[0]);
				utf16[2] = winapi.CharUpper(utf16[2]);
				si (utf16[0] < utf16[2]) responde -1;
				alioqui si (utf16[0] > utf16[2]) responde 1;
				alioqui si (!a[i]) responde 0;
			} alioqui {
				si (a[i] < b[i]) responde -1;
				alioqui si (a[i] > b[i]) responde 1;
				alioqui si (!a[i]) responde 0;
			}
			i++;
		}
	}
	linea inferna { [[thiscall_nullum]] adipisce iacit {
		linea resp(ego^);
		int long = longitudo - 1;
		per (var i : [0, long]) {
			int l = 4;
			ordo [2] nint16 utf16;
			lineae.scribe_characterem(@utf16, l, codex.utf16, resp[i]);
			si (l == 2) {
				utf16[0] = winapi.CharLower(utf16[0]);
				resp._data[i] = lineae.lege_characterem(@utf16, l, codex.utf16);
			}
		}
		responde resp;
	} }
	linea supera { [[thiscall_nullum]] adipisce iacit {
		linea resp(ego^);
		int long = longitudo - 1;
		per (var i : [0, long]) {
			int l = 4;
			ordo [2] nint16 utf16;
			lineae.scribe_characterem(@utf16, l, codex.utf16, resp[i]);
			si (l == 2) {
				utf16[0] = winapi.CharUpper(utf16[0]);
				resp._data[i] = lineae.lege_characterem(@utf16, l, codex.utf16);
			}
		}
		responde resp;
	} }

	classis functio logicum operator == (~linea a, ~linea b) iacit { responde a <=> b == 0; }
	classis functio logicum operator != (~linea a, ~linea b) iacit { responde a <=> b != 0; }
	classis functio logicum operator <= (~linea a, ~linea b) iacit { responde a <=> b <= 0; }
	classis functio logicum operator >= (~linea a, ~linea b) iacit { responde a <=> b >= 0; }
	classis functio logicum operator < (~linea a, ~linea b) iacit { responde a <=> b < 0; }
	classis functio logicum operator > (~linea a, ~linea b) iacit { responde a <=> b > 0; }

	[[thiscall_nullum]] functio int reperi_primum(~linea valor)
	{
		var l = longitudo;
		var s = _data_effectiva;
		var ll = valor.longitudo;
		var ss = valor._data_effectiva;
		per (var i : [0, l - ll]) {
			logicum id = sic;
			per (var j : [0, ll - 1]) si (s[i + j] != ss[j]) { id = non; exi; }
			si (id) responde i;
		}
		responde -1;
	}
	[[thiscall_nullum]] functio int reperi_ultimum(~linea valor)
	{
		var l = longitudo;
		var s = _data_effectiva;
		var ll = valor.longitudo;
		var ss = valor._data_effectiva;
		per (var i : ~[0, l - ll]) {
			logicum id = sic;
			per (var j : [0, ll - 1]) si (s[i + j] != ss[j]) { id = non; exi; }
			si (id) responde i;
		}
		responde -1;
	}
	[[thiscall_nullum]] functio linea fragmentum(int primus, int long) iacit
	{
		var l = longitudo;
		var s = _data_effectiva;
		var ult = long >= 0 ? primus + long - 1 : l - 1;
		si (primus < 0) primus = 0;
		alioqui si (primus > l) primus = l;
		si (ult < 0) ult = 0;
		alioqui si (ult > l) ult = l;
		si (ult >= primus) responde linea(@s[primus], (ult - primus + 1), codex.utf32);
		alioqui responde linea();
	}
	[[thiscall_nullum]] functio linea surroga(~linea sublinea, ~linea cum) iacit
	{
		linea subj = ego^;
		linea resp;
		int long = cum.longitudo;
		dum (subj.longitudo) {
			int ps = subj.reperi_primum(sublinea);
			si (ps >= 0) {
				si (ps) resp += subj.fragmentum(0, ps);
				si (long) resp += cum;
				subj = subj.fragmentum(ps + sublinea.longitudo, -1);
			} alioqui {
				resp += subj;
				subj = "";
			}
		}
		responde resp;
	}
	[[thiscall_nullum]] functio int longitudo_codicis(codex cdx) iacit { responde lineae.mensura_longitudinem(_data_effectiva, cdx) / lineae.longitudo_characteris(cdx); }
	[[thiscall_nullum]] functio nihil codifica(@nihil data, codex cdx, logicum termina) iacit
	{
		var fin = termina ? longitudo : longitudo - 1;
		var dta = (@nint8)(data);
		var ps = 0;
		per (var i : [0, fin]) {
			int pss = 4;
			lineae.scribe_characterem(@dta[ps], pss, cdx, _data_effectiva[i]);
			ps += pss;
		}
	}

	classis functio nint64 _ad_int(@char ln, int long, ~linea radix, logicum sensitivus) iacit
	{
		si (long < 1) iace errores.efformatio_falsa;
		nint64 valor = 0;
		linea L1, L2;
		@char rdx, vlr;
		int rdx_long = radix.longitudo;
		si (sensitivus) {
			vlr = ln;
			rdx = radix;
		} alioqui {
			L1 = linea(ln, -1, codex.utf32).supera;
			L2 = radix.supera;
			vlr = L1;
			rdx = L2;
		}
		si (rdx_long < 2) iace errores.argumentum_falsum;
		nint64 valor_maximus = 0xFFFFFFFFFFFFFFFF / nint64(rdx_long) + nint64(1);
		int i = 0;
		dum (vlr[i]) {
			int num = -1;
			per (var j : [0, rdx_long - 1]) si (vlr[i] == rdx[j]) { num = j; exi; }
			si (num == -1) iace errores.efformatio_falsa;
			si (valor >= valor_maximus) iace errores.efformatio_falsa;
			valor *= rdx_long;
			si (valor > 0xFFFFFFFFFFFFFFFF - nint64(num)) iace errores.efformatio_falsa;
			valor += num;
			i++;
		}
		responde valor;
	}
	classis functio dfrac _ad_frac(~linea ln, @char puncta, int num_punct) iacit
	{
		int long = ln.longitudo;
		si (long < 1) iace errores.efformatio_falsa;
		dfrac valor = 0.0;
		logicum sgn = non;
		int initium = 0;
		si (ln[0] == char('-')) { initium = 1; sgn = sic; }
		alioqui si (ln[0] == char('+')) { initium = 1; }
		int fp = long;
		per (var i : [0, num_punct - 1]) {
			var fpr = ln.reperi_primum(linea(puncta[i], 1));
			si (fpr != -1 && fpr < fp) fp = fpr;
		}
		per (var i : [0, num_punct - 1]) {
			var fpr = ln.reperi_ultimum(linea(puncta[i], 1));
			si (fpr > fp) iace errores.efformatio_falsa;
		}
		per (var i : [initium, fp - 1]) {
			si (ln[i] < char('0') || ln[i] > char('9')) iace errores.efformatio_falsa;
			var num = ln[i] - char('0');
			valor *= 10.0;
			valor += dfrac(num);
		}
		dfrac E = 1.0;
		per (var i : [fp + 1, long - 1]) {
			si (ln[i] < char('0') || ln[i] > char('9')) iace errores.efformatio_falsa;
			var num = ln[i] - char('0');
			E /= 10.0;
			valor += E * dfrac(num);
		}
		responde sgn ? -valor : valor;
	}

	[[thiscall_nullum]] functio int32 ad_int32() iacit { responde ad_int32(radix_decima, sic); }
	[[thiscall_nullum]] functio int32 ad_int32(~linea radix) iacit { responde ad_int32(radix, non); }
	[[thiscall_nullum]] functio int32 ad_int32(~linea radix, logicum sensitivus) iacit
	{
		si (_data == nullus) iace errores.efformatio_falsa;
		logicum sgn = non;
		int initium = 0;
		si (_data[0] == char('-')) { initium = 1; sgn = sic; }
		alioqui si (_data[0] == char('+')) { initium = 1; }
		var valor = _ad_int(@_data[initium], longitudo - initium, radix, sensitivus);
		si (sgn) {
			si (valor > nint64(0x80000000)) iace errores.efformatio_falsa;
			alioqui responde -int32(valor);
		} alioqui {
			si (valor > nint64(0x7FFFFFFF)) iace errores.efformatio_falsa;
			alioqui responde int32(valor);
		}
	}
	[[thiscall_nullum]] functio nint32 ad_nint32() iacit { responde ad_nint32(radix_decima, sic); }
	[[thiscall_nullum]] functio nint32 ad_nint32(~linea radix) iacit { responde ad_nint32(radix, non); }
	[[thiscall_nullum]] functio nint32 ad_nint32(~linea radix, logicum sensitivus) iacit
	{
		si (_data == nullus) iace errores.efformatio_falsa;
		var valor = _ad_int(_data, longitudo, radix, sensitivus);
		si (valor > nint64(0xFFFFFFFF)) iace errores.efformatio_falsa;
		responde nint32(valor);
	}
	[[thiscall_nullum]] functio int64 ad_int64() iacit { responde ad_int64(radix_decima, sic); }
	[[thiscall_nullum]] functio int64 ad_int64(~linea radix) iacit { responde ad_int64(radix, non); }
	[[thiscall_nullum]] functio int64 ad_int64(~linea radix, logicum sensitivus) iacit
	{
		si (_data == nullus) iace errores.efformatio_falsa;
		logicum sgn = non;
		int initium = 0;
		si (_data[0] == char('-')) { initium = 1; sgn = sic; }
		alioqui si (_data[0] == char('+')) { initium = 1; }
		var valor = _ad_int(@_data[initium], longitudo - initium, radix, sensitivus);
		si (sgn) {
			si (valor > nint64(0x8000000000000000)) iace errores.efformatio_falsa;
			alioqui responde -int64(valor);
		} alioqui {
			si (valor > nint64(0x7FFFFFFFFFFFFFFF)) iace errores.efformatio_falsa;
			alioqui responde int64(valor);
		}
	}
	[[thiscall_nullum]] functio nint64 ad_nint64() iacit { responde ad_nint64(radix_decima, sic); }
	[[thiscall_nullum]] functio nint64 ad_nint64(~linea radix) iacit { responde ad_nint64(radix, non); }
	[[thiscall_nullum]] functio nint64 ad_nint64(~linea radix, logicum sensitivus) iacit { responde _ad_int(_data_effectiva, longitudo, radix, sensitivus); }
	[[thiscall_nullum]] functio frac ad_frac() iacit { responde _ad_frac(ego^, ".,", 2); }
	[[thiscall_nullum]] functio frac ad_frac(~linea punctum) iacit { responde _ad_frac(ego^, punctum, punctum.longitudo); }
	[[thiscall_nullum]] functio dfrac ad_dfrac() iacit { responde _ad_frac(ego^, ".,", 2); }
	[[thiscall_nullum]] functio dfrac ad_dfrac(~linea punctum) iacit { responde _ad_frac(ego^, punctum, punctum.longitudo); }
}
genus linea_secura hereditat linea {
	structor () {}
	structor (~linea_secura valor) { _data = valor._data; valor._data = nullus; }
	[[thiscall_nullum]] structor (~linea valor)
	{
		si (valor.longitudo) {
			int long = 4 * (valor.longitudo + 1);
			_data = (@char)(memoria.alloca(long));
			si (_data != nullus) memoria.exscribe(_data, valor._data, long);
		}
	}
}

[[magnitudo] "0:2"] genus virtualis objectum {
	[[positus] "0:1"] nint _num_ref;

	structor () { funda _num_ref(1); }
	functio nint contine() virtualis { responde incrementum_securum(_num_ref); }
	functio nint dimitte() virtualis { var nr = decrementum_securum(_num_ref); si (nr == nint(0)) perde ego; responde nr; }
	destructor () virtualis {}
	functio nihil _perde() virtualis { perde ego; }
	functio linea_secura ad_lineam() virtualis { proba { responde linea("objectum"); } responde linea_secura(); }
}
genus objectum_dynamicum hereditat objectum {
	structor () {}
	functio @nihil converte_dynamice(@nihil gen) iacit virtualis pura;
	functio @nihil para_classem() virtualis pura;
}
protocollum dynamicum {
	functio @nihil converte_dynamice(@nihil gen) iacit virtualis pura;
	functio @nihil para_classem() virtualis pura;
}

praeforma functio permuta(T) { \cense T genus(_0)\ functio nihil $_(~$T t1, ~$T t2) {
	ordo [magnitudo_maxima($T)] nint8 m;
	memoria.exscribe(@m, @t1, magnitudo(t1));
	memoria.exscribe(@t1, @t2, magnitudo(t1));
	memoria.exscribe(@t2, @m, magnitudo(t1));
} }
praeforma genus dordo(V) { genus $_ hereditat objectum {
	@$V _data;
	int _numerus;
	int _allocatus;
	int _talea;
	nomen_alternum genus_objectum = $V;

	functio int _poli(int num) { responde ((num + _talea - 1) / _talea) * _talea; }
	functio nihil _adde(~$V v) iacit { initia(@_data[_numerus], v); _numerus++; }
	functio nihil _realloca(int num) iacit
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _allocatus) {
			si (numerus_novus > _allocatus) {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; } alioqui iace errores.memoria_nulla;
			} alioqui {
				var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
				si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
			}
		}
	}
	functio nihil _realloca_secura(int num)
	{
		int numerus_novus = _poli(num);
		si (numerus_novus != _numerus) {
			var novum = (@$V)(memoria.realloca(_data, magnitudo($V) * nintadl(numerus_novus)));
			si (novum != nullus || !numerus_novus) { _data = novum; _allocatus = numerus_novus; }
		}
	}

	structor () { funda _numerus(0); funda _allocatus(0); funda _talea(0x100); _data = nullus; }
	structor (~dordo[$V] valor) iacit
	{
		funda _numerus(valor._numerus);
		funda _allocatus(0);
		funda _talea(valor._talea);
		_data = nullus;
		_realloca(_numerus);
		int i = 0;
		proba { per (i = 0; i < _numerus; i++) initia(@_data[i], valor._data[i]); } cape (intadl e, intadl se) {
			per (int j = i - 1; j >= 0; j--) fini(_data[i]);
			memoria.dimitte(_data);
			iace e, se;
		}
	}
	structor (int talea) { funda _numerus(0); funda _allocatus(0); funda _talea(talea); _data = nullus; }
	destructor() redefini { per (int i = 0; i < _numerus; i++) fini(_data[i]); memoria.dimitte(_data); }

	functio ~dordo[$V] operator = (~dordo[$V] valor) iacit
	{
		si (ego == @valor) responde ego^;
		dordo[$V] copia(valor);
		per (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = copia._data;
		_numerus = copia._numerus;
		_allocatus = copia._allocatus;
		_talea = copia._talea;
		copia._data = nullus;
		copia._numerus = copia._allocatus = 0;
		responde ego^;
	}
	functio ~$V operator [] (int i) { responde _data[i]; }
	convertor (@$V) () { responde _data; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~$V v) iacit { o.adde(v); responde o; }
	classis functio ~dordo[$V] operator << (~dordo[$V] o, ~dordo[$V] o2) iacit { o.adde(o2); responde o; }

	functio nihil adde(~$V v) iacit { _realloca(_numerus + 1); _adde(v); }
	functio nihil adde(~dordo[$V] o) iacit
	{
		si (ego == @o) iace errores.argumentum_falsum;
		_realloca(_numerus + o._numerus);
		per (int i = 0; i < o._numerus; i++) _adde(o._data[i]);
	}
	functio nihil adde(@$V v, int numerus) iacit
	{
		si (!numerus) responde;
		si (v == _data) iace errores.argumentum_falsum;
		_realloca(_numerus + numerus);
		per (int i = 0; i < numerus; i++) _adde(v[i]);
	}
	functio nihil permuta(int i, int j) { .permuta(_data[i], _data[j]); }
	functio nihil insere(~$V v, int pos) iacit
	{
		_realloca(_numerus + 1);
		per (int i = _numerus - 1; i >= pos; i--) .permuta(_data[i], _data[i + 1]);
		proba { initia(@_data[pos], v); _numerus++; }
		cape (intadl e, intadl se) { per (int i = pos; i < _numerus; i++) .permuta(_data[i], _data[i + 1]); iace e, se; }
	}
	functio nihil remove(int pos)
	{
		fini _data[pos];
		per (int i = pos; i < _numerus - 1; i++) .permuta(_data[i], _data[i + 1]);
		_numerus--; _realloca_secura(_numerus);
	}
	functio nihil remove_primum() { remove(0); }
	functio nihil remove_ultimum() { remove(_numerus - 1); }
	functio nihil depura()
	{
		per (int i = 0; i < _numerus; i++) fini(_data[i]);
		memoria.dimitte(_data);
		_data = nullus;
		_numerus = _allocatus = 0;
	}
	functio ~$V primus() { responde _data[0]; }
	functio ~$V ultimus() { responde _data[_numerus - 1]; }

	functio linea_secura ad_lineam() redefini
	{
		proba {
			linea resp = "ordo : [";
			per (int i = 0; i < _numerus; i++) {
				si (i) resp += ", ";
				resp += linea.ex(_data[i]);
			}
			responde resp + "]";
		}
		responde linea_secura();
	}

	int longitudo {
		adipisce { responde _numerus; }
		\si tractus.habet_structor($V)\ loca iacit {
			si (valor > _numerus) {
				_realloca(valor); int i;
				proba { per (i = _numerus; i < valor; i++) initia(@_data[i]); }
				cape (intadl e, intadl se) { per (int j = i - 1; j >= _numerus; j--) fini _data[j]; iace e, se; }
				_numerus = valor;
			} alioqui si (valor < _numerus) {
				si (valor < 0) iace errores.argumentum_falsum;
				per (int i = valor; i < _numerus; i++) fini _data[i];
				_numerus = valor; _realloca_secura(valor);
			}
		} \fini\
	}
	@$V data { adipisce { responde _data; } }

	functio int initus() { responde 0; }
	functio int finis() { responde _numerus - 1; }
	functio int prae_initus() { responde -1; }
	functio int post_finis() { responde _numerus; }
} }
praeforma genus adl(O) { genus $_ {
	@$O _adl;
	nomen_alternum genus_objectum = $O;
	structor () { _adl = nullus; }
	structor (@$O o) { _adl = o; }
	structor (~adl[$O] o) { _adl = o._adl; si(_adl != nullus) _adl^.contine(); }
	destructor () { si(_adl != nullus) _adl^.dimitte(); }
	functio ~$O operator ^ () { responde _adl^; }
	functio logicum operator ! () { responde _adl == nullus; }
	functio ~adl[$O] operator = (~adl[$O] valor)
	{
		si (ego == @valor) responde ego^;
		si (_adl != nullus) _adl^.dimitte();
		_adl = valor._adl;
		si (_adl != nullus) _adl^.contine();
		responde ego^;
	}
	convertor (@$O) () { responde _adl; }
	convertor (logicum) () { responde _adl != nullus; }
	functio @$O valor() { responde _adl; }
	functio @@$O valor_adl() { responde @_adl; }
	functio nihil depura() { si (_adl != nullus) _adl^.dimitte(); _adl = nullus; }
	functio nihil contine(@$O o) { si (_adl != nullus) _adl^.dimitte(); _adl = o; si (_adl != nullus) _adl^.contine(); }
	functio linea_secura ad_lineam()
	{
		proba {
			si (_adl == nullus) responde linea("nullus");
			alioqui responde _adl^.ad_lineam();
		}
		responde linea_secura();
	}
	classis functio logicum operator == (~adl[$O] a, ~adl[$O] b) { responde a._adl == b._adl; }
	classis functio logicum operator != (~adl[$O] a, ~adl[$O] b) { responde a._adl != b._adl; }
	classis functio logicum operator == (~adl[$O] a, @$O b) { responde a._adl == b; }
	classis functio logicum operator != (~adl[$O] a, @$O b) { responde a._adl != b; }
	classis functio logicum operator == (@$O a, ~adl[$O] b) { responde a == b._adl; }
	classis functio logicum operator != (@$O a, ~adl[$O] b) { responde a != b._adl; }
} }
praeforma genus duplex(A, B) { structura $_ {
	$A primus;
	$B secundus;
	structor (~$A a, ~$B b) iacit { funda primus(a); funda secundus(b); }
} }
praeforma genus triplex(A, B, C) { structura $_ {
	$A primus;
	$B secundus;
	$C tertius;
	structor (~$A a, ~$B b, ~$C c) iacit { funda primus(a); funda secundus(b); funda tertius(c); }
} }
praeforma genus quadriplex(A, B, C, D) { structura $_ {
	$A primus;
	$B secundus;
	$C tertius;
	$D quartus;
	structor (~$A a, ~$B b, ~$C c, ~$D d) iacit { funda primus(a); funda secundus(b); funda tertius(c); funda quartus(d); }
} }

nomen_alternum dordo_linearum = dordo[linea];
nomen_alternum dordo_datorum = dordo[nint8];

dura linea {
	[[thiscall_nullum]] functio adl[dordo_datorum] codifica(codex cdx, logicum termina) iacit
	{
		var long = (longitudo_codicis(cdx) + int(termina)) * lineae.longitudo_characteris(cdx);
		var resp = crea(dordo_datorum, long);
		resp^.longitudo = long;
		codifica(resp^.data, cdx, termina);
		responde resp;
	}
	[[thiscall_nullum]] functio adl[dordo_linearum] scinde(char s) iacit
	{
		var resp = crea(dordo_linearum);
		int long = longitudo;
		int initium = 0;
		dum (sic) {
			int finis = initium;
			dum (finis < long && _data_effectiva[finis] != s) finis++;
			resp^.adde(fragmentum(initium, finis - initium));
			si (finis < long) initium = finis + 1;
			alioqui exi;
		}
		responde resp;
	}
	classis functio linea forma(~linea schema, ~linea a0) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('5')) resp.adde(a5, a5.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('5')) resp.adde(a5, a5.longitudo);
				alioqui si (schema[i] == char('6')) resp.adde(a6, a6.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('5')) resp.adde(a5, a5.longitudo);
				alioqui si (schema[i] == char('6')) resp.adde(a6, a6.longitudo);
				alioqui si (schema[i] == char('7')) resp.adde(a7, a7.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('5')) resp.adde(a5, a5.longitudo);
				alioqui si (schema[i] == char('6')) resp.adde(a6, a6.longitudo);
				alioqui si (schema[i] == char('7')) resp.adde(a7, a7.longitudo);
				alioqui si (schema[i] == char('8')) resp.adde(a8, a8.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}
	classis functio linea forma(~linea schema, ~linea a0, ~linea a1, ~linea a2, ~linea a3, ~linea a4, ~linea a5, ~linea a6, ~linea a7, ~linea a8, ~linea a9) iacit
	{
		ordo char resp;
		var long = schema.longitudo;
		per (var i = 0; i < long; i++) {
			si (schema[i] == char('%')) {
				i++;
				si (schema[i] == char('0')) resp.adde(a0, a0.longitudo);
				alioqui si (schema[i] == char('1')) resp.adde(a1, a1.longitudo);
				alioqui si (schema[i] == char('2')) resp.adde(a2, a2.longitudo);
				alioqui si (schema[i] == char('3')) resp.adde(a3, a3.longitudo);
				alioqui si (schema[i] == char('4')) resp.adde(a4, a4.longitudo);
				alioqui si (schema[i] == char('5')) resp.adde(a5, a5.longitudo);
				alioqui si (schema[i] == char('6')) resp.adde(a6, a6.longitudo);
				alioqui si (schema[i] == char('7')) resp.adde(a7, a7.longitudo);
				alioqui si (schema[i] == char('8')) resp.adde(a8, a8.longitudo);
				alioqui si (schema[i] == char('9')) resp.adde(a9, a9.longitudo);
				alioqui si (schema[i] == char('%')) resp.adde(char('%'));
			} alioqui resp << schema[i];
		}
		responde linea(resp.data, resp.longitudo, codex.utf32);
	}

	praeforma functio ex(T) { \cense T genus(_0)\ functio linea $_(~$T t) iacit {
		\si tractus.convertitur($T, linea)\
			responde linea(t);
		\fini\
		\si !tractus.convertitur($T, linea)\
			\si tractus.habet($T, "ad_lineam")\
				\si tractus.habet_vers($T.ad_lineam)\
					responde t.ad_lineam();
				\fini\
				\si !tractus.habet_vers($T.ad_lineam)\
					responde "?";
				\fini\
			\fini\
			\si !tractus.habet($T, "ad_lineam")\
				\si tractus.est_cls($T)\
					linea r = "structura " + tractus.nomen($T) + " : [\n";
					\replica F $T\
						r += linea(tractus.nomen($T.\loca F\)) + " = " + linea.ex(t.\loca F\) + "\n";
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_ordo($T)\
					linea r = "ordo : [";
					\replica N $T\
						si (\loca N\) r += ", ";
						r += linea.ex(t[\loca N\]);
					\fini\
					responde r + "]";
				\fini\
				\si tractus.est_adl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_fadl($T)\
					responde linea((@nihil)(t));
				\fini\
				\si tractus.est_com($T)\
					responde linea((@nihil)(@t));
				\fini\
				responde "?";
			\fini\
		\fini\
	} }
}
spatium actuarius {
	functio nihil scribe(~linea ln) {}
}