auxilium attributum ("NomenModuli") = "Liber Canonicalis";
auxilium attributum ("CreatorModuli") = "Engine Software";
auxilium attributum ("IuraExempli") = "© Engine Software. 2024";
auxilium attributum ("Versio") = "1.0.0.1";

importa cor;
importa memoria;
importa lineae;

[[systema] libera]

/*
// TODO: IMPLEMENT
spatium math {
	spatium caecus {
		[[importa] fpu_ncg_1]	functio nihil data(@nihil data, int long);
		[[importa] fpu_ncg_2]	functio int integer(int min, int max);
		[[importa] fpu_ncg_3]	functio dfrac fractus();
	}

	[[importa] fpu_f32_pi]	functio frac inf_pos_s();
	[[importa] fpu_f32_ni]	functio frac inf_neg_s();
	[[importa] fpu_f32_nn]	functio frac nn_s();
	[[importa] fpu_f64_pi]	functio dfrac inf_pos_d();
	[[importa] fpu_f64_ni]	functio dfrac inf_neg_d();
	[[importa] fpu_f64_nn]	functio dfrac nn_d();
	[[importa] fpu_ei_32]	functio logicum inf_est(frac valor);
	[[importa] fpu_ei_64]	functio logicum inf_est(dfrac valor);
	[[importa] fpu_enn_32]	functio logicum nn_est(frac valor);
	[[importa] fpu_enn_64]	functio logicum nn_est(dfrac valor);

	[[importa] fpu_sgn_i8]	functio int8	sgn(int8 valor);
	[[importa] fpu_sgn_i16]	functio int16	sgn(int16 valor);
	[[importa] fpu_sgn_i32]	functio int32	sgn(int32 valor);
	[[importa] fpu_sgn_i64]	functio int64	sgn(int64 valor);
	[[importa] fpu_sgn_iad]	functio intadl	sgn(intadl valor);
	[[importa] fpu_sgn_f32]	functio frac	sgn(frac valor);
	[[importa] fpu_sgn_f64]	functio dfrac	sgn(dfrac valor);

	[[importa] fpu_c1]		functio frac	concava(frac valor);
	[[importa] fpu_c1_d]	functio dfrac	concava(dfrac valor);
	[[importa] fpu_c2]		functio frac	trunca(frac valor);
	[[importa] fpu_c2_d]	functio dfrac	trunca(dfrac valor);
	[[importa] fpu_c3]		functio frac	solum(frac valor);
	[[importa] fpu_c3_d]	functio dfrac	solum(dfrac valor);
	[[importa] fpu_c4]		functio frac	tectum(frac valor);
	[[importa] fpu_c4_d]	functio dfrac	tectum(dfrac valor);

	[[importa] fpu_pot]		functio frac	pot(frac valor, frac pot);
	[[importa] fpu_pot_d]	functio dfrac	pot(dfrac valor, dfrac pot);

	[[importa] fpu_exp]		functio frac	exp(frac valor);
	[[importa] fpu_exp_d]	functio dfrac	exp(dfrac valor);
	[[importa] fpu_ln]		functio frac	ln(frac valor);
	[[importa] fpu_ln_d]	functio dfrac	ln(dfrac valor);
	[[importa] fpu_lb]		functio frac	lb(frac valor);
	[[importa] fpu_lb_d]	functio dfrac	lb(dfrac valor);
	[[importa] fpu_lg]		functio frac	lg(frac valor);
	[[importa] fpu_lg_d]	functio dfrac	lg(dfrac valor);

	[[importa] fpu_sin]		functio frac	sin(frac valor);
	[[importa] fpu_sin_d]	functio dfrac	sin(dfrac valor);
	[[importa] fpu_cos]		functio frac	cos(frac valor);
	[[importa] fpu_cos_d]	functio dfrac	cos(dfrac valor);
	[[importa] fpu_tg]		functio frac	tg(frac valor);
	[[importa] fpu_tg_d]	functio dfrac	tg(dfrac valor);
	[[importa] fpu_ctg]		functio frac	ctg(frac valor);
	[[importa] fpu_ctg_d]	functio dfrac	ctg(dfrac valor);

	[[importa] fpu_asin]	functio frac	arcsin(frac valor);
	[[importa] fpu_asin_d]	functio dfrac	arcsin(dfrac valor);
	[[importa] fpu_acos]	functio frac	arccos(frac valor);
	[[importa] fpu_acos_d]	functio dfrac	arccos(dfrac valor);
	[[importa] fpu_atg]		functio frac	arctg(frac valor);
	[[importa] fpu_atg_d]	functio dfrac	arctg(dfrac valor);
	[[importa] fpu_actg]	functio frac	arcctg(frac valor);
	[[importa] fpu_actg_d]	functio dfrac	arcctg(dfrac valor);
}

spatium errores {
	[[importa] descriptio_erroris] functio nihil _descriptio_erroris(nintadl ec, nintadl esc, @nihil mdl, ~linea error, ~linea sub_error);
	functio nihil descriptio(nintadl ec, nintadl esc, ~linea error, ~linea sub_error) { _descriptio_erroris(ec, esc, modulus(), error, sub_error); }
}
spatium actuarius {
	protocollum _actuarius { functio nihil scribe(~linea ln) virtualis pura; }
	functio nihil scribe(~linea ln) { (@_actuarius)(protocollum(actuarius))^.scribe(ln); }
}
spatium systema {
	enumeratio architectura {
		ignota	= 0x00,
		i386	= 0x01,
		x64		= 0x11,
		arm_m32	= 0x02,
		arm_a64	= 0x12
	}
	enumeratio operans {
		ignota	= 0x00,
		windows	= 0x01,
		macos	= 0x02,
		linux	= 0x03
	}

	structura informatio {
		int64 frequentia_processoris;
		int64 numerus_memoriae;
		linea nomen_processoris;
		operans systema_machinae;
		architectura architectura_machinae;
		architectura architectura_processi;
		int32 numerus_cordium_corporalium;
		int32 numerus_cordium_virtualium;
		int32 versio_systemae_supera;
		int32 versio_systemae_inferna;
	}

	[[importa] sys_info]	functio nihil para_informatio(~informatio inf);
	[[importa] sys_temp]	functio nint32 para_tempus_systemae();
	[[importa] sys_arch]	functio logicum proba_architecturam(architectura arch);
}

[[significatio] integer] genus tempus {
	nint64 momentum;

	structor () {}
	structor (tempus valor) { funda momentum(valor.momentum); }
	structor (nint64 valor) { funda momentum(valor); }
	[[thiscall_nullum]] [[importa] tmp_crea_7] structor (int annus, int mensis, int dies, int hora, int minuta, int secunda, int millisecunda);
	[[thiscall_nullum]] [[importa] tmp_crea_4] structor (int hora, int minuta, int secunda, int millisecunda);

	classis functio logicum operator == (tempus a, tempus b) { responde a.momentum == b.momentum; }
	classis functio logicum operator != (tempus a, tempus b) { responde a.momentum != b.momentum; }
	classis functio logicum operator <= (tempus a, tempus b) { responde a.momentum <= b.momentum; }
	classis functio logicum operator >= (tempus a, tempus b) { responde a.momentum >= b.momentum; }
	classis functio logicum operator < (tempus a, tempus b) { responde a.momentum < b.momentum; }
	classis functio logicum operator > (tempus a, tempus b) { responde a.momentum > b.momentum; }

	classis functio tempus operator + (tempus a, tempus b) { responde a.momentum + b.momentum; }
	classis functio tempus operator - (tempus a, tempus b) { responde a.momentum - b.momentum; }

	convertor (nint64) () { responde momentum; }
	functio ~tempus operator = (tempus t) { momentum = t.momentum; responde ego^; }
	functio ~tempus operator += (tempus t) { momentum += t.momentum; responde ego^; }
	functio ~tempus operator -= (tempus t) { momentum -= t.momentum; responde ego^; }

	int annus { [[thiscall_nullum]] [[importa] tmp_a_ans] adipisce; }
	int mensis { [[thiscall_nullum]] [[importa] tmp_a_mns] adipisce; }
	int dies_septimanae { [[thiscall_nullum]] [[importa] tmp_a_dis] adipisce; }
	int dies { [[thiscall_nullum]] [[importa] tmp_a_die] adipisce; }
	int hora { [[thiscall_nullum]] [[importa] tmp_a_hor] adipisce; }
	int minuta { [[thiscall_nullum]] [[importa] tmp_a_min] adipisce; }
	int secunda { [[thiscall_nullum]] [[importa] tmp_a_sec] adipisce; }
	int millisecunda { [[thiscall_nullum]] [[importa] tmp_a_msc] adipisce; }

	tempus tempus_universalus { [[thiscall_nullum]] [[importa] tmp_a_uni] adipisce; }
	tempus tempus_localis { [[thiscall_nullum]] [[importa] tmp_a_loc] adipisce; }

	[[thiscall_nullum]] [[importa] tmp_adl] functio linea ad_lineam() iacit;
	[[thiscall_nullum]] [[importa] tmp_alb] functio linea ad_lineam_brevem() iacit;

	[[importa] tmp_cur] classis functio tempus currens();
	[[thiscall_nullum]] [[importa] tmp_dim] functio int dies_in_mense();
}

genus flumen hereditat objectum {
	constatus initus	= 0;
	constatus currens	= 1;
	constatus finis		= 2;

	structor () {}
	functio int lege(@nihil data, int long) iacit virtualis pura;
	functio nihil scribe(@nihil data, int long) iacit virtualis pura;
	functio int64 quaerita(int64 pos, int origo) iacit virtualis pura;
	int64 longitudo {
		adipisce iacit virtualis pura;
		loca iacit virtualis pura;
	}
	functio nihil annoda() virtualis pura;
	functio logicum _est_xv() virtualis { responde sic; }

	[[thiscall_nullum]] [[importa] flumen_ex_2] functio nihil exscribe(@flumen in, int64 long) iacit;
	[[thiscall_nullum]] [[importa] flumen_ex_1] functio nihil exscribe(@flumen in) iacit;
	[[thiscall_nullum]] [[importa] flumen_lo_1] functio adl[dordo_datorum] lege_ordinem(int long) iacit;
	[[thiscall_nullum]] [[importa] flumen_lo_0] functio adl[dordo_datorum] lege_ordinem() iacit;
	[[thiscall_nullum]] [[importa] flumen_so_1] functio nihil scribe_ordinem(@dordo_datorum ord) iacit;
}

[[importa] flumen_mem_0] functio adl[flumen] crea_flumen_in_memoria() iacit;
[[importa] flumen_mem_2] functio adl[flumen] crea_flumen_in_memoria(@nihil data, intadl long) iacit;
[[importa] flumen_auxil] functio adl[flumen] para_auxilium(@nihil mod, ~linea aux_genus, int aux_num) iacit;

spatium scriptio {
	constatus character_finis = 0xFFFFFFFF;
	genus codificator hereditat objectum {
		structor () {}
		functio nihil scribe(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam(~linea ln) iacit virtualis pura;
		functio nihil scribe_lineam() iacit virtualis pura;
		functio nihil scribe_subscriptionem() iacit virtualis pura;

		classis functio ~codificator operator << (~codificator cdf, ~linea ln) iacit { cdf.scribe(ln); responde cdf; }
	}
	genus decodificator hereditat objectum {
		structor () {}
		functio char lege_characterem() iacit virtualis pura;
		functio linea lege_lineam() iacit virtualis pura;
		functio linea lege_cunctos() iacit virtualis pura;

		logicum finis { adipisce virtualis pura; }
		linea.codex codex { adipisce virtualis pura; }

		classis functio ~decodificator operator >> (~decodificator cdf, ~linea ln) iacit { ln = cdf.lege_lineam(); responde cdf; }
	}

	[[importa] scr_cod_1] functio adl[codificator] codifica(@flumen fl) iacit;
	[[importa] scr_cod_2] functio adl[codificator] codifica(@flumen fl, linea.codex codex) iacit;
	[[importa] scr_dec_1] functio adl[decodificator] decodifica(@flumen fl) iacit;
	[[importa] scr_dec_2] functio adl[decodificator] decodifica(@flumen fl, linea.codex codex) iacit;
}
spatium contextus {
	genus semaphorum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil aperi() virtualis pura;
	}
	genus signale hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		functio logicum opperire(nint ms) virtualis pura;
		functio nihil erige() virtualis pura;
		functio nihil inclina() virtualis pura;
	}
	genus labos hereditat objectum {
		structor () {}
		functio nihil exeque(@objectum ctx) virtualis pura;
	}
	genus labos_opperitus hereditat labos {
		adl[signale] valor_publicus_signale_opperirendi;
		structor () iacit { valor_publicus_signale_opperirendi = crea_signale(); si (!valor_publicus_signale_opperirendi) iace errores.memoria_nulla; }
		functio nihil exeque(@objectum ctx) redefini {}
	}
	genus filum hereditat objectum {
		structor () {}
		functio nihil opperire() virtualis pura;
		logicum activum { adipisce virtualis pura; }
		int numerus_exitus { adipisce virtualis pura; }
	}
	genus cauda hereditat objectum {
		structor () {}
		functio logicum adde(@labos lab) virtualis pura;
		functio logicum adde(@@labos lab, int num) virtualis pura;
	}
	genus cauda_simplex hereditat cauda {
		structor () {}
		functio nihil exeque() virtualis pura;
		functio logicum exeque_semel() virtualis pura;
		functio adl[filum] exeque_in_filo() virtualis pura;
		functio nihil siste() virtualis pura;
		functio nihil linque() virtualis pura;
		int longitudo { adipisce virtualis pura; }
	}
	genus cauda_filorum hereditat cauda {
		structor () {}
		functio nihil para_statum(~int num_fil, ~int num_act_fil, ~int num_lab) virtualis pura;
		functio nihil opperire() virtualis pura;
	}

	[[importa] ctx_dormi] functio nihil dormi(nint ms);
	[[importa] ctx_siste] functio nihil siste(nint valor);

	[[importa] ctx_ccsim] functio adl[cauda_simplex] crea_caudam_simplicem();
	[[importa] ctx_ccfl0] functio adl[cauda_filorum] crea_caudam_filorum();
	[[importa] ctx_ccfl1] functio adl[cauda_filorum] crea_caudam_filorum(int num);
	[[importa] ctx_crsem] functio adl[semaphorum] crea_semaphorum(int valor);
	[[importa] ctx_crsgn] functio adl[signale] crea_signale();
	[[importa] ctx_crfil] functio adl[filum] exeque(@labos lab);

	functio nihil exeque_in_contextu(@cauda ctx, @labos lab) { ctx^.adde(lab); }
	functio adl[signale] exeque_in_contextu_et_opperire(@cauda ctx, @labos_opperitus lab) { ctx^.adde(lab); responde lab^.valor_publicus_signale_opperirendi; }
}

praeforma operator muta_contextum(C) { .contextus.exeque_in_contextu($C, .contextus.labos ## { $_ }) }
praeforma operator muta_contextum_et_opperire(C) { .contextus.exeque_in_contextu_et_opperire($C, .contextus.labos_opperitus ## { $_ }) }

genus meta hereditat objectum {
	constatus attributum_nomen_moduli	= "NomenModuli";
	constatus attributum_creator_moduli	= "CreatorModuli";
	constatus attributum_iura_exempli	= "IuraExempli";
	constatus attributum_versio			= "Versio";

	structor() {}

	functio int initus() virtualis pura;
	functio int finis() virtualis pura;
	functio int prae_initus() virtualis pura;
	functio int post_finis() virtualis pura;

	functio linea operator [] (int num) iacit virtualis pura;
	functio linea operator [] (~linea attr) iacit virtualis pura;

	[[importa] meta_moduli] classis functio adl[meta] moduli(@nihil mdl) iacit;
}
*/