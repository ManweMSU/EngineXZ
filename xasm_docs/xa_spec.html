<html>
	<head>
		<meta charset="UTF-8">
		<title>Общее описание Engine XA</title>
		<style type="text/css">
			body {
				font-family:Cambria, Cochin, Georgia, Times, 'Times New Roman', serif
			}
			h1 {
				font-weight: normal;
			}
			h2 {
				font-weight: normal;
			}
			table {
				text-align: center;
				border-color: #404040;
				border-style: double;
			}
			td {
				border-color: #404040;
				border-style: dotted;
			}
			.code {
				font-family: 'Courier New', Courier, monospace;
				font-weight: bolder;
			}
			.red {
				background-color: #FF8080;
			}
			.green {
				background-color: #80FF80;
			}
			.bold {
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<h1>Общее описание Engine XA</h1>
		<p>
			Engine XA - технология платформонезависимого описания логики подпрограмм и их трансляции в машинный код.
			Для описания подпрограммы используется её специальное представление (ассемблер).
		</p>
		<p>
			Описание подпрограммы включает в себя:
			<ul>
				<li>Таблицу текстовых ссылок на внешние объекты</li>
				<li>Внутренние (приватные для подпрограммы) данные</li>
				<li>Спецификацию вызова</li>
				<li>Сами инструкции</li>
			</ul>
		</p>
		<h2>Ссылки на внешние объекты</h2>
		<p>
			Каждая такая ссылка это строка. Объект, на который данная ссылка указывает разрешается во время размещения
			данной подпрограммы в памяти для исполнения и после трансляции в машинный код. В текстовом представлении для создания ссылки
			используется слово EXTERNAL. После него следует строковый литерал - содержимое ссылки. Возможно использование блока {} со строковыми
			литералами внутри для объявления нескольких ссылок. Пример:
			<br><span class="code">
				EXTERNAL "ref1"<br>
				EXTERNAL { "ref2" "ref3" }
			</span><br>
			Объявляет 3 ссылки ref1, ref2 и ref3. Порядок ссылок имеет значение для их дальнейшего использования.
		</p>
		<h2>Внутренние данные</h2>
		<p>
			Внутренние данные могут содержать любую информацию. Они доступны для произвольного чтения и записи только самой подпрограммой.
			Для объявления очередной порции данных используется слово DATA. После него следует либо элементарное описание одной порции данных,
			либо последовательность описаний, заключённая в {}. Элементарное описание данных имеет следующий синтаксис:
			<br><span class="code">
				АТОМ_ДАННЫХ := ( 'BYTE' | 'WORD' | 'DWORD' | 'QWORD' ) ( 'ALIGN' | ( [ '+' ] [ '-' ] ЛИТЕРАЛ ) )
			</span><br>
			Слова BYTE, WORD, DWORD и QWORD задают размер атома данных в 1, 2, 4 или 8 байт соответственно.
			Использование далее слова ALIGN приводит к набивке внутренних данных подпрограммы нулями до выравнивания их размера на границу атома данных.
			Иначе во внутренние данные кодируется представленный литерал.
		</p>
		<table>
			<tr class="bold">
				<td><b>Размер атома</b></td><td><b>Целочисленный литерал</b></td><td><b>Вещественный литерал</b></td><td><b>Строковый литерал</b></td>
			</tr>
			<tr>
				<td>BYTE / 1</td><td class="green">uint8</td><td class="red">Не поддерживается</td><td class="green">Строка UTF-8</td>
			</tr>
			<tr>
				<td>WORD / 2</td><td class="green">uint16</td><td class="red">Не поддерживается</td><td class="green">Строка UTF-16 LE</td>
			</tr>
			<tr>
				<td>DWORD / 4</td><td class="green">uint32</td><td class="green">float</td><td class="green">Строка UTF-32 LE</td>
			</tr>
			<tr>
				<td>QWORD / 8</td><td class="green">uint64</td><td class="green">double</td><td class="red">Не поддерживается</td>
			</tr>
		</table>
		<p>
			При кодировании строки в блок данных помещается несколько атомов данных, включая нулевой атом - символ конца строки.
		</p>
		<h2>Интерфейс подпрограммы. Описание интерфейсов</h2>
		<p>
			Интерфейс определяет порядок передачи параметров подпрограммы при её вызове. Описание интерфейса необходимо и
			при описании подпрограммы и при вызове других подпрограмм/встроенных функций из неё. Для декларации интерфейса используется синтаксис:
			<br><span class="code">
				ДЕКЛАРАЦИЯ_ИНТЕРФЕЙСА := 'INTERFACE' ОПИСАНИЕ_ИНТЕРФЕЙСА
			</span><br>
			Само описание интерфейса имеет синтаксис:
			<br><span class="code">
				ОПИСАНИЕ_ИНТЕРФЕЙСА := { ОПИСАНИЕ_ПАРАМЕТРА } '=>' ОПИСАНИЕ_ПАРАМЕТРА
			</span><br>
			Первые N описаний параметра определяют входные аргументы подпрограммы, финальный - возвращаемое значение.
			<br><span class="code">
				ОПИСАНИЕ_ПАРАМЕТРА := РАЗМЕР [ ':' СЕМАНТИКА ]
			</span><br>
			Размер определяет размер области данных, требуемой для данного параметра.
			<br><span class="code">
				РАЗМЕР := ( ЧИСЛО | 'W' ЧИСЛО | ЧИСЛО 'W' ЧИСЛО )
			</span><br>
			До спецсимвола W следует размер объекта в байтах, после - размер в машинных словах.
			Размер объекта определяется как сумма двух данных размеров. Машинное слово - количество байт, требуемое для хранения указателя.<br>
			Семантика параметра опционально указывает тип данных, который предполагается передавать с данным аргументом.
			Семантика имеет существенное значение при вызове подпрограмм. При обращении ко встроенным функциям она, напротив, игнорируется.
			Определены следующие семантики:
			<ui>
				<li><span class="code">'?'</span> - семантика не известна. Значение по умолчанию для аргументов нулевой длины.</li>
				<li><span class="code">'-'</span> - объект без классификации. Значение по умолчанию для аргументов не нулевой длины.</li>
				<li><span class="code">'UINT'</span> - передаётся целочисленное беззнаковое значение.</li>
				<li><span class="code">'INT', 'SINT'</span> - передаётся целочисленное знаковое значение.</li>
				<li><span class="code">'FLOAT'</span> - передаётся значение с плавающей запятой.</li>
				<li><span class="code">'OBJECT'</span> - передаётся объект с нетривиальной логикой хранения.</li>
				<li><span class="code">'THIS'</span> - передаётся указатель на экземпляр класса.</li>
				<li><span class="code">'RTTI'</span> - передаётся указатель на данные о типах.</li>
				<li><span class="code">'ERROR'</span> - передаётся указатель на данные об ошибках.</li>
			</ui>
		</p>
		<h2>Инструкции подпрограммы</h2>
		<p>
			Инструкции выполняются последовательно, если иное не предусмотрено самой инструкцией.
			Инструкции манипулируют данными через концепцию мета-регистров. Определены следующие регистры:
			<ul>
				<li>E[n] - ссылка на внешний объект. n - индекс (отсчёт с 0) ссылки на этот объект в таблице внешних ссылок.</li>
				<li>D[n] - ссылка на внутренние данные подпрограммы. n - сдвиг в байтах от начала блока внутренних данных.</li>
				<li>C - ссылка на саму подпрограмму. Может использоваться для рекурсии или создания указателя на себя.</li>
				<li>A[n] - ссылка на входной аргумент подпрограммы. n - индекс (отсчёт с 0) этого аргумента (см. интерфейс подпрограммы).</li>
				<li>R - ссылка возвращаемое значение. Подпрограмма обязана записать в него результат своей работы, если это предусмотрено её интерфейсом.</li>
				<li>L[n] - ссылка на локальное значение. Локальные значения создаются и уничтожаются динамически в ходе выполнения подпрограммы.
					n - индекс локального значения, 0 - самое древнее из существующих в данный момент значений.</li>
				<li>I - ссылка на значение, подлежащее в данный момент инициализации.</li>
				<li>S - ссылка на значение, полученное в результате операции SPLIT.</li>
			</ul>
		</p>
		<p>
			Для определения инструкций используется следующий синтаксис:
			<br><span class="code">
				ИНСТРУКЦИИ := 'CODE' '{' { ИНСТРУКЦИЯ } '}'
			</span><br>
			<span class="code">
				ИНСТРУКЦИЯ := ПСЕВДОНИМ_ОПЕРАЦИИ [ '{' ДЕРЕВО_ВЫЧИСЛЕНИЙ '}' ] [ '#' ФИНАЛИЗАТОР ] [ '@' РАЗМЕР ]
			</span><br>
			Определены следующие операции:
		</p>
		<table>
			<tr class="bold">
				<td>Псевдоним</td><td>Использует дерево?</td><td>Использует финализатор?</td><td>Использует размер?</td><td>Описание</td>
			</tr>
			<tr>
				<td>NOP</td><td class="red">Нет</td><td class="red">Нет</td><td class="red">Нет</td><td>Ничего не делает.</td>
			</tr>
			<tr>
				<td>TRAP</td><td class="red">Нет</td><td class="red">Нет</td><td class="red">Нет</td>
				<td>Устанавливает инструкцию-ловушку, вызывающую отладчик или аварийное завершение работы.</td>
			</tr>
			<tr>
				<td>ENTER</td><td class="red">Нет</td><td class="red">Нет</td><td class="red">Нет</td>
				<td>Открывает новую область локальных значений. Должен иметь парный LEAVE в коде ниже.</td>
			</tr>
			<tr>
				<td>LEAVE</td><td class="red">Нет</td><td class="red">Нет</td><td class="red">Нет</td>
				<td>Закрывает текущую область локальных значений. Должен иметь парный ENTER в коде выше.</td>
			</tr>
			<tr>
				<td>EVAL</td><td class="green">Да</td><td class="red">Нет</td><td class="red">Нет</td>
				<td>Выполняет <b>дерево</b> вычислений.</td>
			</tr>
			<tr>
				<td>NEW</td><td class="green">Да</td><td class="green">Да</td><td class="green">Да</td>
				<td>
					Создаёт новое локальное значение в текущей области локальных значений. Новое значение имеет заданный <b>размер</b>.
					Значение существует до момента окончания существования текущей области локальных значений или выхода из неё с помощью JUMP/JUMPIF.
					Перед уничтожением локального значения вызывается указанный <b>финализатор</b>. Новое значение может быть инициализировано
					<b>деревом</b> вычислений. Дерево будет иметь к нему доступ через регистр I.
				</td>
			</tr>
			<tr>
				<td>JUMP</td><td class="red">Нет</td><td class="red">Нет</td><td class="green">Да</td>
				<td>
					Выполняет безусловный переход по <b>указанному (в байтовом поле размера)</b> относительному (относительно следующей инструкции) адресу.
					Операцию перехода <b>нельзя</b> использовать для входа в область локальных значений, но можно использовать для выхода.
				</td>
			</tr>
			<tr>
				<td>JUMPIF</td><td class="green">Да</td><td class="red">Нет</td><td class="green">Да</td>
				<td>
					Если логическое значение, полученное в ходе вычисления <b>дерева</b>, истинно, то выполняет условный переход
					по заданному <b>относительному смещению</b>. Подробности и ограничения см. в JUMP.
				</td>
			</tr>
			<tr>
				<td>RET</td><td class="green">Да</td><td class="red">Нет</td><td class="red">Нет</td>
				<td>
					Выполняет указанное <b>дерево</b> вычислений и возвращает управление вызвавшей стороне.
					Предполагается, что дерево инициализирует регистр возвращаемого значения R, но данная операция может быть выполнена и ранее.
					Выполнение любой подпрограммы обязано заканчиваться инструкцией RET. Данная инструкция, помимо возврата управления,
					закрывает все области локальных значений и вызывает соответствующие финализаторы.
				</td>
			</tr>
		</table>
		<p>
			Финализатор используется для выполнения нестандартных действий, связанных с уничтожением объектов в памяти.
			Финализатор - подпрограмма, получающая на вход 1 или более указателей и не возвращающая ничего.
			Синтаксис описания финализатора:
			<br><span class="code">
				ФИНАЛИЗАТОР := РЕГИСТР [ '(' РЕГИСТР { ',' РЕГИСТР } ')' ]
			</span><br>
			Первый регистр содержит саму подпрограмму-финализатор.
			Финализатор всегда получает на вход указатель на уничтожаемый объект как первый параметр.
			Вариант синтаксиса со () используется для передачи дополнительных параметров.
			Тогда финализатор получит также указатели на регистры, указанные в () в порядке их перечисления.
		</p>
		<p>
			При вычислении дерева могут образовываться внутренние временные объекты/значения, требующие или не требующие финализации.
			Гарантируется, что данные объекты существуют до полного окончания вычисления дерева.
			Исключения - условно вычисляемые ветви дерева в операциях ALL, ANY и FORK.
			Их временные объекты уничтожаются сразу после вычисления условной ветви.
			Дерево имеет следующий синтаксис:
			<br><span class="code">
				ДЕРЕВО_ВЫЧИСЛЕНИЙ :=
			</span><br>
			<span class="code">
			&nbsp;&nbsp;&nbsp;&nbsp;РЕГИСТР | '-'
			</span><br>
			<span class="code">
			или
			</span><br>
			<span class="code">
			&nbsp;&nbsp;&nbsp;&nbsp;( РЕГИСТР | '@' ВСТРОЕННАЯ_ФУНКЦИЯ ) [ '!' ] ':' ОПИСАНИЕ_ИНТЕРФЕЙСА '(' [ ДЕРЕВО_ВЫЧИСЛЕНИЙ { ',' ДЕРЕВО_ВЫЧИСЛЕНИЙ } ] ')' [ '#' ФИНАЛИЗАТОР ]
			</span><br>
			Первый вариант синтаксиса используется для листьев деревьев и определяет входные данные вычисления.
			Второй вариант используется для узлов и определяет преобразование поступающих данных.
			В случае указания регистра используется вызов внешней подпрограммы.
			Иначе указывается стандартная встроенная функция ассемблера, осуществляющая преобразование. Полный список встроенных функций см. в отдельном документе.
			Описание интерфейса - обязательно к использованию. Оно используется для определения соглашения о вызовах в случае вызова внешней подпрограммы
			и для определения размеров аргументов в случае встроенных функций.
			Возвращаемые значения входных поддеревьев должны быть согласованы и по количеству и по размеру с описанием интерфейса.
			Результатом вычисления узла дерева является новое значение. В случае внешнего вызова и в случае использования встроенной функции NEW
			для данного нового значения можно указать финализатор.
			Символ '!', приписанный к преобразованию 'BLT' указывает, что некоторые из аргументов не имеют натурального выравнивания в памяти.
		</p>
	</body>
</html>